<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Activity(Fragment)的生命周期和启动模式 生命周期分析典型的生命周期 activity的生命周期    fragment的生命周期   与宿主Activity的生命周期的关系    onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？ 对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索总结">
<meta property="og:url" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/index.html">
<meta property="og:site_name" content="yyg的小黑屋">
<meta property="og:description" content="Activity(Fragment)的生命周期和启动模式 生命周期分析典型的生命周期 activity的生命周期    fragment的生命周期   与宿主Activity的生命周期的关系    onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？ 对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_lifecycle.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_launch_mode.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/Binder.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/Binder_module-table.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/IPC.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/android_view_hierarchy.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/motion_event_method.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/Window的内部机制.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity启动流程.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/service_lifecycle.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/dialog.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/Handler消息机制.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/TCP.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/TCP_shake_hands_LI.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/TCP_wave_hands.png">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1524205439643&di=a5edd509b8a7945fc4ffbd20aed67db3&imgtype=0&src=http%3A%2F%2Fs1.knowsky.com%2F20170221%2Fvbru5sfvszb03.png">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/LinkedHashMap.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/HashSet.png">
<meta property="og:updated_time" content="2018-04-23T03:31:05.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索总结">
<meta name="twitter:description" content="Activity(Fragment)的生命周期和启动模式 生命周期分析典型的生命周期 activity的生命周期    fragment的生命周期   与宿主Activity的生命周期的关系    onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？ 对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop">
<meta name="twitter:image" content="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/activity_lifecycle.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/"/>





  <title>Android开发艺术探索总结 | yyg的小黑屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyg的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yyglike.com/2018/04/19/Android开发艺术探索总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yyg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyg的小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T16:43:47+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Activity-Fragment-的生命周期和启动模式"><a href="#Activity-Fragment-的生命周期和启动模式" class="headerlink" title="Activity(Fragment)的生命周期和启动模式"></a>Activity(Fragment)的生命周期和启动模式</h4><ol>
<li><h5 id="生命周期分析"><a href="#生命周期分析" class="headerlink" title="生命周期分析"></a>生命周期分析</h5><h6 id="典型的生命周期"><a href="#典型的生命周期" class="headerlink" title="典型的生命周期"></a>典型的生命周期</h6><ol>
<li><p><strong>activity的生命周期</strong></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/activity_lifecycle.PNG" alt=""></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/activity_lifecycle_table.PNG" alt=""></p>
</li>
<li><p><strong>fragment的生命周期</strong></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/fragment_lifecycle.png" alt=""></p>
</li>
<li><p><strong>与宿主Activity的生命周期的关系</strong></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/activity_fragment_lifecycle.png" alt=""></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG" alt=""></p>
</li>
<li><p><strong>onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？</strong></p>
<p>对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop是从activity这个角度来回调的，此时是无法操作的 ; onResume和onPause是从activity是否位于前台来回调，此时由可操作变为不克操作。</p>
</li>
</ol>
<h5 id="异常情况下的生命周期分析及一些思考问题"><a href="#异常情况下的生命周期分析及一些思考问题" class="headerlink" title="异常情况下的生命周期分析及一些思考问题"></a>异常情况下的生命周期分析及一些思考问题</h5><ol>
<li><p><strong>横竖屏切换时Activity的异常生命周期变化?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">      Activity创建：</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      竖屏切横屏：</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">      onPause--&gt;</span><br><span class="line">      onStop--&gt;</span><br><span class="line">      onDestroy--&gt;</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onRestoreInstanceState--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      横屏切换竖屏</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br><span class="line">onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析</strong></p>
<ul>
<li><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>
</li>
<li><p>设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>
</li>
<li><p>设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
</li>
<li><p>补充：Activity运行时按下HOME键(跟被完全覆盖是一样的)：<br>onSaveInstanceState –&gt; onPause –&gt; onStop;<br>重新回到Activity=： onRestart –&gt;onStart—&gt;onResume<br>Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</p>
</li>
</ul>
</li>
</ol>
</li>
<li><h5 id="Activity是如何保存和恢复View的结构？"><a href="#Activity是如何保存和恢复View的结构？" class="headerlink" title="Activity是如何保存和恢复View的结构？"></a>Activity是如何保存和恢复View的结构？</h5><p> 首先，activity被意外终止时，activity会调用onSaveInstanceState()去保存数据，然后activity会委托Window去保存数据，接着window委托它的上级容器去保存数据。顶级容器是一个ViewGroup，一般可能是是DecorView。最后顶级容器再去一一通知子元素去保存数据，对于数据的恢复也是类似的。</p>
</li>
<li><h5 id="资源不足导致低优先级的activity被杀死"><a href="#资源不足导致低优先级的activity被杀死" class="headerlink" title="资源不足导致低优先级的activity被杀死"></a>资源不足导致低优先级的activity被杀死</h5><p> activity的优先级：<br> 1.<code>前台activity</code>——正在和用户交互的activity，优先级最高<br> 2.<code>可见但非前台activity</code>—–比如activity中弹出一个对话框，导致activity可见但是位于后台无法与直接交互。<br> 3.<code>后台activity</code>—-已经被暂停的activity，比如执行了onStop(),优先级最低</p>
<p> 对于系统内存不足时，系统会按照优先级来杀死目标activity的进程，然后通过onSaveInstanceState()和onRestoreInstanceState()一bundle的形式存储恢复数据。但是onSaveInstanceState()这个方法只会出现在activity被异常终止时，它出现在onStop()之前，但是和onPuase()没有既定的关系，可能出现在之前也可能是之后。</p>
</li>
<li><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p> <strong>假设当前activity为A,若此时用户打开activity B，那么 B 的onResume()和 A 的OnPause()那个先执行？</strong></p>
<p> 当新启动一个activity时，位于栈顶的旧activity的onPause()会先执行，才会启动新的activity，另外Android对onPause()的解释是不能在其中进行重量级的操作，为了新的activity尽快出现在前台，所以也可以说明西先onPause在onResume,注意：资源回收等重量尽量在onStop()中进行.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onPause(A)--&gt;onCreat(B)--&gt;onStart(B)--&gt;onResume(B)--&gt;onStop(A)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>须知：最开始的两张图展示的 Fragment 与 Activity 的生命周期关系没毛病。<br>onAttach() 和 onCreate() 只在 Fragment 与 Activity 第一次关联时调用。<br>onDestroy() 和 onDetach() 只在 Fragment 的宿主 Activity 销毁时才会被调用。</p>
</blockquote>
<p><strong>通过 addToBackStack() 将 Fragment 放入回退栈，然后通过 popBackStack() 出栈，Fragment 的生命周期会如何变化呢？</strong><br>  所以将 Fragment 通过 addToBackStack() 只涉及 onCreateView() 和 onDestroyView() 这之间的生命周期。add() 和 replace() 不会对 Fragment 的生命周期产生影响，但 add() 方法会造成 Fragment 叠加显示。</p>
<p><strong>如果 Fragment 与 ViewPager 结合使用，Fragment 的生命周期又是如何？</strong><br>  Fragment 与 ViewPager 结合使用时的只涉及 onCreateView() 和 onDestroyView() 这之间的生命周期生命周期。</p>
<p><strong>如果通过 hide() 和 show() 方法来展示隐藏，这时 Fragment 的生命周期又会如何？</strong><br>通过 hide() 、 show() 来隐藏、显示Fragment，此时 Fragment 只改变了可见性，并不涉及生命周期的改变</p>
<p><strong>Fragment 和 Activity 的生命周期有关，即：不要在 Fragment 的 onCreate() 方法中操作宿主Activity 的 UI。因为你无法保证此时 宿主Activity 的 UI 已经完全初始化。PS:某些情况下是可以确保 宿主Activity 已经初始化完成的。</strong></p>
<p><strong><a href="https://www.jianshu.com/p/5c32bf28b653" target="_blank" rel="noopener">如何理解 Activity 的生命周期</a></strong></p>
</li>
</ol>
<ol start="2">
<li><h5 id="Android的启动模式"><a href="#Android的启动模式" class="headerlink" title="Android的启动模式"></a>Android的启动模式</h5><p><img src="/2018/04/19/Android开发艺术探索总结/activity_launch_mode.PNG" alt=""></p>
<h6 id="activity的startActivity和context的startActivity区别"><a href="#activity的startActivity和context的startActivity区别" class="headerlink" title="activity的startActivity和context的startActivity区别"></a>activity的startActivity和context的startActivity区别</h6><ul>
<li><p>从Activity中启动新的Activity时可以直接mContext.startActivity(intent)就好，</p>
</li>
<li><p>如果从其他Context中启动Activity则必须给intent设置Flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK) ;</span><br><span class="line">mContext.startActivity(intent);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="https://www.jianshu.com/p/b60d8097e519" target="_blank" rel="noopener">说说 Activity 的四种启动模式</a></strong></p>
</li>
<li><h5 id="Acticity和Fragment的通信方式"><a href="#Acticity和Fragment的通信方式" class="headerlink" title="Acticity和Fragment的通信方式"></a>Acticity和Fragment的通信方式</h5>？？？？？</li>
</ol>
<h4 id="进程间通信IPC机制"><a href="#进程间通信IPC机制" class="headerlink" title="进程间通信IPC机制"></a>进程间通信IPC机制</h4><ol>
<li><h5 id="什么是IPC？"><a href="#什么是IPC？" class="headerlink" title="什么是IPC？"></a>什么是IPC？</h5>IPC,Inter-Process Communication的缩写，含义为进程通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br><code>**线程**：</code>cup调度的最小单位<br><code>**进程**：</code>一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。<br><code>**ANR**:</code>在主线程中进行大量的耗时操作导致界面无法响应。</li>
<li><h5 id="什么是多进程？"><a href="#什么是多进程？" class="headerlink" title="什么是多进程？"></a>什么是多进程？</h5><h6 id="如何开启多进程？"><a href="#如何开启多进程？" class="headerlink" title="如何开启多进程？"></a>如何开启多进程？</h6><p> Android中只有一种方式开启多进程，就是在四大组件的啊AndroidMenifest中指定android:process属性。</p>
<h6 id="多进程的运行机制？"><a href="#多进程的运行机制？" class="headerlink" title="多进程的运行机制？"></a>多进程的运行机制？</h6><p> 开启多进程造成的问题：</p>
<ul>
<li>静态成员和单列模式完成失效</li>
<li>线程同步机制失效</li>
<li>SharePreferences的可靠性失效</li>
<li>Application会多次创建</li>
</ul>
<h6 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h6><p>  为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即Android的进程是<code>相互独立</code>、<code>隔离的</code></p>
</li>
<li><h5 id="Android-Binder跨进程通信的原理"><a href="#Android-Binder跨进程通信的原理" class="headerlink" title="Android Binder跨进程通信的原理"></a>Android Binder跨进程通信的原理</h5><h6 id="Binder是什么？"><a href="#Binder是什么？" class="headerlink" title="Binder是什么？"></a>Binder是什么？</h6><p>  <img src="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br>  <strong>说人话—-</strong></p>
<ul>
<li><p><code>直观角度</code>：Binder是Android的一个类，实现了IBinder接口</p>
</li>
<li><p><code>IPC角度</code>：Binder是Android一种跨进程通信的方式</p>
</li>
<li><p><code>Android Framework角度</code>: Binder是<code>ServiceManager</code>连接各        种Manager(<code>ActivityManager</code>、<code>WindowManger</code>)和相应ManagerService的桥梁</p>
</li>
<li><p><code>android应用层角度</code>：Binder是客户端和服务端进行通信的媒介。binderService的时候服务端会返回一个包含服务端业务调用的Binder对象，通过这个binder对象客户端可以获取服务端提供的服务和数据(包含该普通服务和基于AIDL的服务)</p>
</li>
</ul>
<h6 id="Binder跨进程通信原理"><a href="#Binder跨进程通信原理" class="headerlink" title="Binder跨进程通信原理"></a>Binder跨进程通信原理</h6><p><img src="/2018/04/19/Android开发艺术探索总结/Binder.png" alt="通信原理图"></p>
<p>无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务, 当然查找懂啊目标信息可以缓存起来则不需要每次都向ServiceManager请求。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ul>
<li><p>1.注册服务：首先Server注册到ServiceManager。该过程：Server所在进程(system_server)是客户端，ServiceManager是服务端。</p>
</li>
<li><p>2.获取服务：Client进程使用Server前，须先向ServiceManager中获取Serve的代理。该过程：Client所在进程(app process)是客户端，ServiceManager是服务端。</p>
</li>
<li><p>3.使用服务： app进程根据得到的代理类,便可以直接与Server所在进程交互。该过程：Client所在进程(app process)是客户端，Server所在进程(system_server)是服务端。</p>
</li>
</ul>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder Driver进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层.<br>这3大过程每一次都是一个完整的Binder IPC过程.</p>
<h6 id="各个模块的作用："><a href="#各个模块的作用：" class="headerlink" title="各个模块的作用："></a>各个模块的作用：</h6><p><img src="/2018/04/19/Android开发艺术探索总结/Binder_module-table.PNG" alt="各模块的作用"></p>
<h6 id="ServerManager是如何管理server的？"><a href="#ServerManager是如何管理server的？" class="headerlink" title="ServerManager是如何管理server的？"></a>ServerManager是如何管理server的？</h6><ul>
<li><p><strong>Binder Client 通过ServerManager获取Binder的引用，binder的引用是由SeverManager转换或者说映射得到的</strong>。</p>
</li>
<li><p><strong>Binder Server在生成一个Binder实体的同时会为其绑定一个名字，并将这个名字封装成一个数据包传递给Binder Driver</strong>；</p>
</li>
<li><p><strong>Binder Driver接收到数据包之后，如果是新的Binder，会为它在内存空间中创建相应的实体节点和一个对实体节点的引用，在源码中中分别对应Binder_node和Binder_ref；创建完后，Binder Driver 会将该引用传递给ServerManager;</strong></p>
</li>
<li><p><strong>ServerManager接收到之后会从中取出该Binder的名字和引用然后插入到一个数据表中，如此形成了类似DNS中存储的域名到真实IP的映射，然后Binder Client就可利用ServerManager通过名字查询Binder的引用，获取服务</strong>。</p>
</li>
<li><strong>当然Binder并非一定在ServerManager中有记录，很多时候Binder Server会将一个Binder实体封装进数据包传递给Binder Client,此时Binder server会在数据包中标注Binder实体的位置，Binder Driver会为该匿名的Binder生成实体节点和引用，并将引用通过映射传递给Binder Clien </strong><h6 id="跨进程通信的核心原理"><a href="#跨进程通信的核心原理" class="headerlink" title="跨进程通信的核心原理"></a>跨进程通信的核心原理</h6></li>
</ul>
<p><strong>关于其核心原理：内存映射，具体请看文章：<a href="https://www.jianshu.com/p/719fc4758813" target="_blank" rel="noopener">操作系统：图文详解 内存映射</a> </strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/" alt="Binder Driver"></p>
<h5 id="Binder通信原理图："><a href="#Binder通信原理图：" class="headerlink" title="Binder通信原理图："></a>Binder通信原理图：</h5><p><img src="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/" alt="Binder原理图"></p>
</li>
<li><h5 id="Android的中IPC方式对比"><a href="#Android的中IPC方式对比" class="headerlink" title="Android的中IPC方式对比"></a>Android的中IPC方式对比</h5><p><img src="/2018/04/19/Android开发艺术探索总结/IPC.PNG" alt=""></p>
</li>
</ol>
<h4 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h4><ol>
<li><h5 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h5><ul>
<li>使用scrollTo/scrollBy<br><code>scrollTo</code>:一次性滑动，屏幕左上角坐标为基准<br><code>scrollBy</code>:多次的，相对于当前位置的</li>
<li>使用动画</li>
<li>改变布局参数</li>
</ul>
</li>
<li><h5 id="事件拦截和分发"><a href="#事件拦截和分发" class="headerlink" title="事件拦截和分发"></a>事件拦截和分发</h5><p><img src="/2018/04/19/Android开发艺术探索总结/android_view_hierarchy.jpg" alt=""><br><strong>先来一段伪代码简单表示事件的传递规则</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">    boolean cousume = flase;</span><br><span class="line">    //拦截</span><br><span class="line">    if(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">        //消费</span><br><span class="line">       consume = onTouchEvent();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       //子view继续分发事件</span><br><span class="line">       consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    return consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MotionEvent=====&gt;Activty-----&gt;Window(PhoneWindow)-------&gt;DecorView----&gt;</span><br><span class="line">---&gt;顶级View(setContentView()，一般是ViewGroup)-------&gt;目标View</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说人话描述上面这段代码</strong>：</p>
</blockquote>
<p><strong>点击事件产生后，经过Activty,PhoneWindow,DecorView的分发传递，事件会传递给顶级View(一般是ViewGroup)，这时候它的dispatchTouchEvent()方法会被调用，<br>如果内部的onInterceptTouchEvent()方法返回true,则表示它拦截当前的事件，特殊的如果ViewGroup的mOnTouchListener被设置，事件会被onTouch()处理，否则事件就正常交给ViewGroup的onTouchEvent()方法会处理；<br>相反，如果ViewGroup的onInterceptTouchEvent()方法返回出false,则表示不拦截当前的事件，这时当前的事件就会传递它的子元素，接着子元素的dispatchTouchEvent()方法会被调用，如此反复直到事件被处理。</strong></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/motion_event_method.png" alt=""></p>
</li>
<li><h5 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h5><ul>
<li><blockquote>
<p><strong>解决ScrollView嵌套ListView和GridView冲突的方法</strong></p>
</blockquote>
<p>重写ListView的onMeasure方法，来自定义高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"> int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST);</span><br><span class="line"> super.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要考察对MeasureSpec的三种模式的理解,相关文章.</p>
</li>
</ul>
</li>
</ol>
<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><ol>
<li><h5 id="View的绘制流程："><a href="#View的绘制流程：" class="headerlink" title="View的绘制流程："></a>View的绘制流程：</h5><p>View的绘制是从ViewRoot的performTraversals()方法开始的，该方法会依次调用performMeasure、performLayout、performDraw三个方法，这三个方法依次完成顶级view的measure、layout、draw。其中perform会调用measure方法，在measure中有会调用onMeasure方法，在onMeasure方法中会对所有的子view进行measure，此时整个measure流程从父容器传到了子元素，完成一次measur过程，接着子元素会重复父容器的measure过程，如此反复完成整个view树的遍历。同理performLayout、performDraw与performMeasure的流程是类似的，最终完成view的绘制。</p>
</li>
<li><h5 id="view的工作流程："><a href="#view的工作流程：" class="headerlink" title="view的工作流程："></a>view的工作流程：</h5><p>主要是指measure、layout、draw这三大流程，其中measure确定view的测量宽/高；layout确定view的最终宽/高和四个顶点的位置；二draw将view绘制在屏幕上。</p>
<p>对于view直接调用onMeasure方法来测量，而ViewGroup是抽象类，没有重写onMeasure方法，而是通过measureChildren遍历子元素，通过measureChild方法调用子元素的measure完成测量；</p>
<p>ViewGroup layout的大致流程：通过setFrame方法来设定view的四个顶点的位置，view的四个顶点一单确定view在父容器的中的位置也就确定，接着调用onLaytout确定子元素的位置;</p>
<ul>
<li>Draw遵循步骤：</li>
<li>1、绘制背景background.draw(canvas);</li>
<li>2、绘制自己onDraw;</li>
<li>3、绘制children–dispatchDraw;</li>
<li>4、绘制装饰—onDrawScrollBars.</li>
</ul>
</li>
<li><h5 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h5><h6 id="自定义View的分类及流程："><a href="#自定义View的分类及流程：" class="headerlink" title="自定义View的分类及流程："></a>自定义View的分类及流程：</h6><ul>
<li><p>1、<strong>继承View重写onDraw方法</strong>；需要自己支持warp_content，处理padding；</p>
</li>
<li><p>2、<strong>继承ViewGroup派生特殊的布局</strong>，方法需要适当的处理ViewGroup的测量和布局的两个过程，并同时处理子元素的布局和测量过程。</p>
</li>
<li><p>3、<strong>继承特定的View</strong>，如TextView，对已有的功能进行拓展，无序自己支持warp_content，处理padding</p>
</li>
<li><p>4、<strong>继承特定的ViewGroup</strong>,如线性布局，此方法不需要自己处理ViewGroup的测量和布局。</p>
</li>
<li><p>5、<strong>为了使自定义的View更易用，还需要添加自定义属性，以便在布局文件中使用：</strong></p>
<ul>
<li>1、在values目录中创建自定义属性xml文件，如attrs.在values目录中创建自定义属性xml文件</li>
<li>2、在view的构造方法中解析自定义的属性，并相应的处理，如定义默认值等。</li>
<li>3、在布局文件中声明然后使用。</li>
</ul>
<h6 id="直接继承view或者ViewGroup的控件，有时候warp-content达不到预期效果？"><a href="#直接继承view或者ViewGroup的控件，有时候warp-content达不到预期效果？" class="headerlink" title="直接继承view或者ViewGroup的控件，有时候warp_content达不到预期效果？"></a>直接继承view或者ViewGroup的控件，有时候warp_content达不到预期效果？</h6><p><code>原因</code>：当view在布局中使用warp_content，此时specMode为AT_MOST，宽高等于specSize，这种情况下View的specSize为parentSize,而parentSized的大小为父容器当前的剩余空间，使得和使用match_parent效果一致。<br><code>解决方法</code>：给View设定默认的宽/高，并在warp_content时根据情况设置此宽/高，即可。</p>
</li>
</ul>
<h6 id="自定义View注意事项"><a href="#自定义View注意事项" class="headerlink" title="自定义View注意事项"></a>自定义View注意事项</h6><ul>
<li><p>1.让View支持warp_content</p>
</li>
<li><p>2.如有必要，让view支持padding</p>
</li>
<li><p>3.尽量不要在view中使用Handler,没必要，view本身提供post方法，完全可以替代Handler的作用，除非明确用handler来发送消息。</p>
</li>
<li><p>View中如果有线程或者动画，需要及时停止，View的OnDetachFromWindow是个好时机，当包含此view的Activity退出或者当前的View被remove是，此方法都会被调用。同事view背的不可见时候也需停止动画或者线程，避免内存泄漏。</p>
</li>
<li><p>View带有嵌套滑动的情形是，需要处理滑动冲突。</p>
</li>
</ul>
</li>
</ol>
<h4 id="Android动画分析"><a href="#Android动画分析" class="headerlink" title="Android动画分析"></a>Android动画分析</h4><ol>
<li><h5 id="Android动画分类：view动画，属性动画和新增的物理动画"><a href="#Android动画分类：view动画，属性动画和新增的物理动画" class="headerlink" title="Android动画分类：view动画，属性动画和新增的物理动画"></a>Android动画分类：view动画，属性动画和新增的物理动画</h5><ul>
<li><p><strong>View动画</strong>：对场景里的对象不断做图像变换（平移，缩放，旋转，透明度）从而产生一系列的动画效果，是一种渐进式动画，支持自定义；它包含该两个特殊的类型帧动画和补间动画：</p>
<ul>
<li>帧动画：通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片的切换动画。图片过多过大会导致oom;</li>
<li>补间动画：是帧动画的特殊形式，只需要提供开始图片和结束图片作为开始帧和结束帧，而动画的中间帧由系统计算补充。</li>
</ul>
</li>
<li><p><strong>属性动画</strong>：通过动态的改变对象的属性从而达到动画效果。</p>
</li>
<li><strong>物理动画</strong>：基于物理规律的动画效果。</li>
</ul>
</li>
<li><h5 id="自定义view动画的及其使用场景"><a href="#自定义view动画的及其使用场景" class="headerlink" title="自定义view动画的及其使用场景"></a>自定义view动画的及其使用场景</h5><h6 id="自定义view动画"><a href="#自定义view动画" class="headerlink" title="自定义view动画"></a>自定义view动画</h6>   继承Animation抽象类—-&gt;重写initialize和applyTransformation方法—–&gt;在initialize中做初始化工作，在applyTransformation中进行相应的矩阵变换。<ul>
<li><code>view动画的特殊使用场景</code>：在ViewGroup中控制元素的出场效果，实现activity的出场动画。</li>
</ul>
</li>
<li><h5 id="属性动画："><a href="#属性动画：" class="headerlink" title="属性动画："></a>属性动画：</h5><p> 常见的几个动画类：ValueAnimator,ObjectAnimator,AnimatorSet。<br> <code>插值器</code>：根据时间流逝的百分比来计算出当前属性值改变的百分比<br> <code>估值器</code>:根据当前属性变化的百分比计算改变后的属性值</p>
<h6 id="属性动画的工作原理："><a href="#属性动画的工作原理：" class="headerlink" title="属性动画的工作原理："></a>属性动画的工作原理：</h6><p> 在一定时间间隔内和值范围内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。因此要求作用的对象有该属性的set方法，如果没有设置初始值，还需要对象提供get方法，或者进行包装设置getter/setter方法。ValueAnimator不断控制值的变化，然后手动赋值给对象的属性，ObjectAnimator直接操作对象属性的值。</p>
</li>
<li><h5 id="使用动画的注意事项："><a href="#使用动画的注意事项：" class="headerlink" title="使用动画的注意事项："></a>使用动画的注意事项：</h5><p> 1、帧动画中如果使用的图片过多多大容易出现OOM;<br> 2、内存泄漏：属性动画中的无限循环动画需要在activity退出时及时停止，避免activity无法释放造成内存泄漏。<br> 3、尽量使用dp保证在不同设备上的效果；<br> 4、动画元素的交互问题：使用view动画移动之后点击事件还在原地，点击移动后的view无效======这是因为view动画只是对控件影像的操作，到达动画视觉的效果，而控件还留在原来的区域。</p>
</li>
</ol>
<h4 id="理解Window和WinowManager"><a href="#理解Window和WinowManager" class="headerlink" title="理解Window和WinowManager"></a>理解Window和WinowManager</h4><ol>
<li><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>Window表示一个窗口的概念，是一个抽象类，Android的所有视图都通过Window呈现，并依附于它，不管是activity、dialog、还是toast，Window都是view的直接管理者。具体实现是PhoneWindow，通过WindowManager创建window，window的外界访问入口是WindowMananger，具体实现在WindowManagerServer中，因此windowmanger和WindowManagerServer的交互式IPC过程。</p>
</li>
<li><h5 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h5><p><img src="/2018/04/19/Android开发艺术探索总结/Window的内部机制.jpg" alt=""></p>
</li>
<li><h5 id="PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"><a href="#PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？" class="headerlink" title="PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"></a>PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？</h5>以Activity中Window创建为例：在activity的实例创建之后会调用Activity的attach方法，此方法中系统会创建Activity所属的Window对象，Window对象的创建是通过PolicyManager的具体实现类Policy类中的makeNewWindow方法实现的，此方法中放返回一个PhoneWindow的实例。因此此过程就是PhoneWindow的实例化过程，而PhoneWindow是Window的具体实现类。</li>
<li><h5 id="Activity的视图创建过程"><a href="#Activity的视图创建过程" class="headerlink" title="Activity的视图创建过程"></a>Activity的视图创建过程</h5><ol>
<li><p>创建Window:Activity的attach方法中通过PolicyManager的makeNewWindow方法创建实现类PhoneWindow;</p>
</li>
<li><p>初始化DecorView并将定义的布局添加到DecorView的<code>mParentContent</code>中，回调；</p>
</li>
<li><p>DecorView已经初始化完毕，ActivityThread的handleResumeActivity方法调用onResume方法，然后在makeVisible()方法中使activity视图可见。</p>
</li>
</ol>
</li>
</ol>
<h4 id="四大组件的工作过程"><a href="#四大组件的工作过程" class="headerlink" title="四大组件的工作过程"></a>四大组件的工作过程</h4><ol>
<li><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>Activity</strong>：展示型组件，向用户展示界面，接收用户输入进行交互；<br><strong>Service</strong>:计算性组件，在后台执行一系列计算任务；<br><strong>BroadcastReceiver</strong>:消息型组件，应用在不同组件乃至不同应用之间传递消息。可实现低耦合观察者模式；<br><strong>ContentProvider</strong>:数据共享型组件，用于向其他组件乃至应用间共享数据。</p>
</li>
<li><h5 id="Activity的工作过程"><a href="#Activity的工作过程" class="headerlink" title="Activity的工作过程"></a>Activity的工作过程</h5><h6 id="activity是如何启动？"><a href="#activity是如何启动？" class="headerlink" title="activity是如何启动？"></a>activity是如何启动？</h6><p><img src="/2018/04/19/Android开发艺术探索总结/activity启动流程.jpg" alt=""></p>
</li>
<li><h5 id="Service的工作过程"><a href="#Service的工作过程" class="headerlink" title="Service的工作过程"></a>Service的工作过程</h5><p><img src="/2018/04/19/Android开发艺术探索总结/service_lifecycle.jpg" alt=""></p>
<h6 id="Service的启动过程和绑定过程"><a href="#Service的启动过程和绑定过程" class="headerlink" title="Service的启动过程和绑定过程"></a>Service的启动过程和绑定过程</h6><h6 id="如何保证Service不被杀死？"><a href="#如何保证Service不被杀死？" class="headerlink" title="如何保证Service不被杀死？"></a>如何保证Service不被杀死？</h6><ul>
<li>1.onStartCommand方法，返回START_STICKY</li>
<li>2.提升service优先级</li>
<li>3.提升service进程优先级</li>
<li>4.onDestroy方法里重启service</li>
<li>5.Application加上Persistent属性</li>
<li>6.双进程保护,两个Service相互唤醒</li>
<li>7.使用JobService(5.0之后)</li>
</ul>
<h6 id="怎么在Service中创建Dialog对话框"><a href="#怎么在Service中创建Dialog对话框" class="headerlink" title="怎么在Service中创建Dialog对话框"></a>怎么在Service中创建Dialog对话框</h6><ol>
<li><p><strong>在Service中创建</strong></p>
<ul>
<li><p>1.构建Dialog对象之后，在show()方法之前设置Dialog 的Window类型为系统警告弹框<br><code>mDialog.getWindow.setType(WindowManger.LayoutParams.TYPE_SYSYTEM_ALERT)</code></p>
</li>
<li><p>2.在AndroidManifest清单文件的申明对应的权限<code>android.permission.SYSTEM_ALERT_WINDOW</code></p>
</li>
<li><p>3.对于6.0以上的版本还需要申请运行时权限：在activity的onResume中判断是否允许绘制叠加层– <code>Settings.canDrawOverlays()</code>，没有则请求。</p>
</li>
</ul>
<p><img src="/2018/04/19/Android开发艺术探索总结/dialog.png" alt=""></p>
</li>
<li><p><strong>在Service中发送广播在Activity中显示</strong></p>
</li>
</ol>
</li>
</ol>
<h4 id="Android的消息机制"><a href="#Android的消息机制" class="headerlink" title="Android的消息机制"></a>Android的消息机制</h4><ol>
<li><h5 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h5> android的消息机制是指Handler的运行机制以及Handler所附带的MessageQueue和Looperd的工作过程，三者是一个整体。Handler 的主要任务是将任务切换到某个指定的线程去执行。</li>
<li><h5 id="消息机制原理"><a href="#消息机制原理" class="headerlink" title="消息机制原理"></a>消息机制原理</h5> <code>message:</code>包含事件的信息以及消息的处理对象,message.next()指向下一个可用的message<br> <code>MessageQueue:</code>一组以单链表形式维护的待处理的消息；<br> <code>Looper:</code>消息循环<br> <code>Handler:</code>消息投递、处理器。<br> <img src="/2018/04/19/Android开发艺术探索总结/Handler消息机制.jpg" alt=""><br> <strong>讲人话====&gt;整个机制就像工厂的生成线，Message是待处理的产品，MessageQueu是传送带，Looper是发动机，而Handler则是工人。工人在生产线一端Thread 1投送待处理的产品Message到传送带MessageQueue上，经过发送机Looper的不停循环转动传送到生产线另一端Thread 2,然后工人拿出产品做相应的处理。</strong></li>
<li><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5> ThreadLocal是线程内部的数据存储类，通过它可以在制定的线程中存储数据，数据存储之后只能在指定的线程中获取到存储的数据，对于其他线程来说则无法获取到。<br> <code>使用时机</code>：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本时。比如,线程的Looper,作用域为当前线程且不线程有不同的Looper;全局的监听器对象。</li>
<li><h5 id="在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"><a href="#在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？" class="headerlink" title="在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"></a>在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？</h5> 因为每个Handler会关联一个消息列队，而消息列队被封装在Looper中，但是每个Looper又是存储在ThreadLocal中的，基于ThreadLocal的特性，也就是说每个消息列队只属于一个线程。因此，如果Looper在线程A中创建，那么Looper只能被线程A访问。不带参数的Handler默认获取了UI线程中的MianLooper,作为消息投递，处理的Handler，要想访问MainLooper所在线程中的消息列队，必须在与之相同的线程中，即UI线程中创建。</li>
<li><h5 id="只能在主线程中更新UI，这种说法对吗？"><a href="#只能在主线程中更新UI，这种说法对吗？" class="headerlink" title="只能在主线程中更新UI，这种说法对吗？"></a>只能在主线程中更新UI，这种说法对吗？</h5>不对，应该说只能在创建UI的线程中更新UI</li>
<li><h5 id="Handler导致的内存泄漏"><a href="#Handler导致的内存泄漏" class="headerlink" title="Handler导致的内存泄漏"></a>Handler导致的内存泄漏</h5><p> 造成泄漏的诱因有两个：1、主线程中的Looper对象的生命周期==应用的生命周期；2、在java中菲静态内部类和匿名内部类默认持有外部类的引用。<br> 由于Looper内部消息队列中的Message默认包含了对处理者handler的引用(msg.traget=handler)，而handler实例默认持有外部类，也就是activity的引用，如果在activity结束时，还有未处理的消息或者正在处理消息，使得引用关系继续保持，从而导致外部类无法被销毁回收，造成内存泄漏。<br> <strong>解决方法：</strong></p>
<ul>
<li><p>1.外部类结束生命周期时清空handler内的消息列队，比如在onDestory中调用 mHandler.removeCallbacksAndMessages(null);</p>
</li>
<li><p>2.将handler设置成静态内部类并对外部类进行弱引用。</p>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li><h5 id="为什么一个线程只有一个Looper、只有一个MessageQueue？"><a href="#为什么一个线程只有一个Looper、只有一个MessageQueue？" class="headerlink" title="为什么一个线程只有一个Looper、只有一个MessageQueue？"></a>为什么一个线程只有一个Looper、只有一个MessageQueue？</h5>ThreadLoca这个线程变量来存储Looper，looper 中实例化MessageQueue，在创建Looper的Looper.prepare()方法中，如果ThreadLocal中已经存在looper会报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">  // 这里是关键，如果这个线程已经存在Looper报异常</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  // 不存在，创建一个Looper设置到sThreadLocal</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Android的线程和线程池"><a href="#Android的线程和线程池" class="headerlink" title="Android的线程和线程池"></a>Android的线程和线程池</h4><ol>
<li><h5 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h5>进程所拥有的的线程叫做主线程，除主线程之外的线程叫做子线程，或工作线程。<br>主线程主要用来是运行四大组件以及处理界面交互相关的逻辑，子线程用来执行耗时操作。</li>
<li><h5 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h5><ol>
<li>传统的Thread</li>
<li>AsyncTask</li>
<li>HandlerThread</li>
<li>IntentService</li>
</ol>
</li>
<li><h5 id="HandlerThread、IntentService理解"><a href="#HandlerThread、IntentService理解" class="headerlink" title="HandlerThread、IntentService理解"></a>HandlerThread、IntentService理解</h5><p>《android开发艺术探索》第十一章</p>
</li>
<li><h5 id="android中的线程池"><a href="#android中的线程池" class="headerlink" title="android中的线程池"></a>android中的线程池</h5><strong>线程池的优点</strong><ul>
<li>重用线程池中线程，避免线程创建和销毁带来的性能开销</li>
<li>能有效控制线程的最大并发数，避免大量线程之间因相互枪战系统资源而导致阻塞。</li>
<li>能够对线程进行简单的控制</li>
</ul>
</li>
<li><strong>线程池的分类</strong><ul>
<li>FixedThreadPool :固定线程数，空闲状态不会被回收</li>
<li>CachedThreadPool : 线程数量不固定，只有非核心线程，闲置状态是被停止</li>
<li>ScheduledThreadPool  :核心线程固定，非核心线程不固定，闲置回收，执行定时或者周期任务</li>
<li>SingleThreadPool :只有一个核心线程，任务在同一个线程中顺序执行</li>
</ul>
</li>
<li><strong>线程池的参数详解</strong><br>？？？？</li>
</ol>
<h4 id="Bitmap的加载和缓存"><a href="#Bitmap的加载和缓存" class="headerlink" title="Bitmap的加载和缓存"></a>Bitmap的加载和缓存</h4><ol>
<li><h5 id="Bitmap的高效加载"><a href="#Bitmap的高效加载" class="headerlink" title="Bitmap的高效加载"></a>Bitmap的高效加载</h5><p>核心思想是：采用BitmapFactory.Option设置采样率inSampleSzie来加载所需尺寸的图片。<br>获取采样率的流程：</p>
<ol>
<li>将BitmapFactory.Option的inJustDecodeBounds参数为true并加载图片;</li>
<li>从BitmapFactory.Option中解析出图片的原始宽高，它们对应于outWidth和outHeight;</li>
<li>根据采样率的规则、结合目标view的大小计算出采样率inSampleSize;</li>
<li>将BitmapFactoory.Option的inJustDecodeBounds设置为false,重新加载图片。</li>
</ol>
</li>
<li><h5 id="高效加载大图"><a href="#高效加载大图" class="headerlink" title="高效加载大图"></a>高效加载大图</h5><p><a href="https://blog.csdn.net/lmj623565791/article/details/49300989" target="_blank" rel="noopener">Android 高清加载巨图方案 拒绝压缩图片</a></p>
</li>
<li><h5 id="android的缓存策略"><a href="#android的缓存策略" class="headerlink" title="android的缓存策略"></a>android的缓存策略</h5><h6 id="android图片的三级缓存"><a href="#android图片的三级缓存" class="headerlink" title="android图片的三级缓存"></a>android图片的三级缓存</h6><ol>
<li><p>首次加载的时候通过网络加载，获取图片，然后保存到内存和 SD 卡中；</p>
</li>
<li><p>之后运行 APP 时，优先访问内存中的图片缓存；</p>
</li>
<li><p>如果内存中没有，则加载本地 SD 卡中的图片,如果内存中没有最后再从网络获取。</p>
<p><strong>具体的缓存策略可以是这样的：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用 LruCache ，其内部通过 LinkedhashMap 以强引用的方式存储外界的缓存对象，并使用Lru最近最少算法维护链表；对于本地缓存，使用 DiskLruCache。加载图片的时候，首先使用 LRU 方式进行寻找，若找不到指定内容，按照三级缓存的方式，进行本地搜索，还没有就网络加载。</strong></p>
</li>
</ol>
</li>
</ol>
<h4 id="Android的性能优化"><a href="#Android的性能优化" class="headerlink" title="Android的性能优化"></a>Android的性能优化</h4><ol>
<li><h5 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h5></li>
<li><h5 id="内存泄露优化"><a href="#内存泄露优化" class="headerlink" title="内存泄露优化"></a>内存泄露优化</h5><a href="https://blog.csdn.net/qq_16628781/article/details/67761590" target="_blank" rel="noopener">Android之内存泄漏以及解决办法</a></li>
<li><h5 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h5></li>
<li><h5 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h5></li>
<li><h5 id="响应速度优化和ANR日志分析"><a href="#响应速度优化和ANR日志分析" class="headerlink" title="响应速度优化和ANR日志分析"></a>响应速度优化和ANR日志分析</h5></li>
<li><h5 id="ListView和Bitmap优化"><a href="#ListView和Bitmap优化" class="headerlink" title="ListView和Bitmap优化"></a>ListView和Bitmap优化</h5>具体详见《Android开发艺术探索》第十五章</li>
</ol>
<h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><ol>
<li><h5 id="简述TCP建立连接的三次握手及原因？"><a href="#简述TCP建立连接的三次握手及原因？" class="headerlink" title="简述TCP建立连接的三次握手及原因？"></a>简述TCP建立连接的三次握手及原因？</h5><p> <img src="/2018/04/19/Android开发艺术探索总结/TCP.jpg" alt=""><br> <strong>ACK(Acknowledgement)</strong>： 确认字符。TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1<br> <strong>SYN(Synchronization)</strong> ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。<br> <strong>FIN（finis）</strong>即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。<br> <strong>步骤：</strong></p>
<ul>
<li>1、<strong>首先由Client发出请求连接报文,即 SYN=1+ACK=0,声明自己的序号是 seq=x</strong></li>
<li>2、<strong>然后Server 进行回复确认，即 SYN=1，声明自己的序号是 seq=y,并设置为ack=x+1,</strong></li>
<li><p>3、<strong>最后Client 再进行一次确认， seq=x+1, ack=y+1。收到确认之后连接建立完毕，可以传输数据</strong></p>
<p><img src="/2018/04/19/Android开发艺术探索总结/TCP_shake_hands_LI.jpg" alt=""><br><strong>原因：</strong></p>
<blockquote>
<p>防止服务器接收到早已失效的连接请求，从而一直等待客户端的请求，导致形成锁死、浪费资源</p>
</blockquote>
</li>
</ul>
<p>假设不采用“三次握手”，即服务器发出确认报文后，TCP连接就建立起来，但是客户端并没有继续发出建立连接的请求报文，因此不会给服务器发送数据，对于客户端来说，该报文已经失效，但是服务器以为TCP连接已建立，然后一直等待客户端发送数据，会形成锁死。<br><strong>就好比</strong>：</p>
<blockquote>
<p>老板只是查个岗，于是在群里随便问：小明在吗？</p>
</blockquote>
<blockquote>
<p>然后就看到了小明迅速的恢复：在的,老板！</p>
</blockquote>
<blockquote>
<p>老板心想：果然没看错小明！然后老板忙自己的去了。</p>
</blockquote>
<p>这时候要是小明是个二货（不进行三次握手），以为老本板有什么任务交给他，就傻傻的等着，等了一天老板也没再说话。这就是不进行三次握手的结果—锁死、浪费资源。</p>
</li>
</ol>
<ol start="2">
<li><h5 id="TCP四次分手"><a href="#TCP四次分手" class="headerlink" title="TCP四次分手"></a>TCP四次分手</h5><p><img src="/2018/04/19/Android开发艺术探索总结/TCP_wave_hands.png" alt=""></p>
<blockquote>
<p><strong>解析：</strong></p>
</blockquote>
<p>假设老板和小明都在加班，一起加班，共同加班——&gt;<code>数据双向传输</code><br>老板一看表两点了啊，于是<br><code>数据单向传输</code><br>老板：小明你的模块提交了没有，提交了早点回去休息，明天还上班呢！</p>
<pre><code>客户端|终止等待1
</code></pre><p>小明：还有一点，马上就好!</p>
<pre><code>服务器|关闭等待
客户端|终止等待2
</code></pre><p>转眼三点了，小明也完成了工具，于是：<br>小明：老板，醒醒，醒醒，我的模块提交了！</p>
<pre><code>服务器|最终确认
</code></pre><p>老板：额，什么，好，我在看一下，你可以走了！明天不要迟到！<br>然后，小明拖着疲倦的身体回了；</p>
<pre><code>服务器|关闭
</code></pre><p>过了没多久—-等小明真的走了</p>
<pre><code>客户端|时间等待
</code></pre><p>老板也收拾东西，开车回家了。</p>
<pre><code>客户端|关闭
</code></pre></li>
<li><h5 id="为什么客户端关闭连接前要等待2MSL时间？"><a href="#为什么客户端关闭连接前要等待2MSL时间？" class="headerlink" title="为什么客户端关闭连接前要等待2MSL时间？"></a>为什么客户端关闭连接前要等待2MSL时间？</h5><p> <code>MSL</code>–最长报文寿命（Maximum Segment Lifetime），报文在网络中存活的事件。</p>
<ul>
<li><p>原因1：为了保证客户端发送的最后1个连接释放确认报文能到达服务器，从而使得服务器能正常释放连接；</p>
</li>
<li><p>原因2：防止客户端已失效的连接请求报文出现在连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。</p>
</li>
</ul>
</li>
<li><h5 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h5><p>DDOS全名是Distribution Denial of service (分布式拒绝服务攻击),很多DOS攻击源一起攻击某台服务器就组成了DDOS攻击。DoS的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使服务器无法处理合法用户的指令。</p>
<p> <strong>未连接队列</strong>：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<p> <strong>Backlog参数</strong>：表示未连接队列的最大容纳数目。</p>
<p> <strong>SYN-ACK重传次数</strong> 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。</p>
<p> <strong>半连接存活时间</strong>：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。</p>
<p> 假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源—-数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的CPU时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。实际上如果服务器的TCP/IP栈不够强大，最后的结果往往是堆栈溢出崩溃—即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称做：服务器端受到了SYN Flood攻击（SYN洪水攻击）</p>
<p> <strong>在服务端返回一个确认的SYN-ACK包的时候有个潜在的弊端，如果发起的客户是一个不存在的客户端，那么服务端就不会接到客户端回应的ACK包。<br> 这时服务端需要耗费一定的数量的系统内存来等待这个未决的连接，直到等待超时关闭，才能施放内存。<br> 如果恶意者通过ip欺骗，发送大量SYN包给受害者系统，导致服务端存在大量未决的连接并占用大量内存和tcp连接，从而导致正常客户端无法访问服务端，这就是SYN洪水攻击的过程。</strong></p>
</li>
</ol>
<h4 id="Http-Https"><a href="#Http-Https" class="headerlink" title="Http/Https"></a>Http/Https</h4><p>详情见<a href="http://www.yyglike.com/2018/04/03/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/#HTTP与HTTPS有什么区别？">HTTP与HTTPS有什么区别</a></p>
<h4 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h4><p>详情见<a href="http://www.yyglike.com/2018/04/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/">Java面试题集</a></p>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p>详情见<a href="http://www.yyglike.com/2018/04/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/">Java面试题集</a></p>
<h4 id="Java的四种引用类型"><a href="#Java的四种引用类型" class="headerlink" title="Java的四种引用类型"></a>Java的四种引用类型</h4><ol>
<li><strong>强引用</strong><br>Java中所有new出来的对象都是强引用类型，回收的时候，GC宁愿抛出OOM异常，也不回收它。</li>
<li><strong>软引用，SoftReference</strong><br>内存足够时，不回收。内存不够时，就回收。</li>
<li><strong>弱引用，WeakReference</strong><br>GC一出来工作就回收它。</li>
<li><strong>虚引用，PhantomReference</strong><br>用完就消失。</li>
</ol>
<h4 id="int、Integer有什么区别"><a href="#int、Integer有什么区别" class="headerlink" title="int、Integer有什么区别"></a>int、Integer有什么区别</h4><ul>
<li><p>Integer是int的包装类，int则是java的一种基本数据类型</p>
</li>
<li><p>Integer变量必须实例化后才能使用，而int变量不需要</p>
</li>
<li><p>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象，所以两个new出来的Integer永远不相等；而int则是直接存储数据值</p>
</li>
<li><p>Integer的默认值是null，int的默认值是0</p>
</li>
<li><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p>
</li>
<li><p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p>
</li>
<li><p>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
</li>
</ul>
<h4 id="动态权限适配问题、换肤实现原理"><a href="#动态权限适配问题、换肤实现原理" class="headerlink" title="动态权限适配问题、换肤实现原理"></a>动态权限适配问题、换肤实现原理</h4><p>  这方面看下鸿洋大神的博文吧<br>  <a href="https://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="noopener">Android 6.0 运行时权限处理完全解析</a></p>
<h4 id="SharedPreference原理，能否跨进程？如何实现？"><a href="#SharedPreference原理，能否跨进程？如何实现？" class="headerlink" title="SharedPreference原理，能否跨进程？如何实现？"></a>SharedPreference原理，能否跨进程？如何实现？</h4><p>《Android开发艺术探索》64 page<br><a href="https://www.jianshu.com/p/875d13458538" target="_blank" rel="noopener">Android SharedPreference 支持多进程</a><br><a href="https://blog.csdn.net/lmj623565791/article/details/72859156" target="_blank" rel="noopener"> Android 7.0 行为变更 通过FileProvider在应用间共享文件吧</a></p>
<h4 id="响应速度优化"><a href="#响应速度优化" class="headerlink" title="响应速度优化"></a>响应速度优化</h4><p>   Activity如果5秒之内无法响应屏幕触碰事件和键盘输入事件，就会出现ANR；<br>而BroadcastReceiver如果10秒之内还未执行操作也会出现ANR，<br>Serve20秒会出现ANR 为了避免ANR，可以开启子线程执行耗时操作，但是子线程不能更新UI，因此需要Handler消息机制、AsyncTask、IntentService进行线程通信。<br>备：出现ANR时，adb pull data/anr/tarces.txt 结合log分析</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol>
<li><h6 id="单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"><a href="#单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理" class="headerlink" title="单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"></a>单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理</h6></li>
<li><h6 id="观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"><a href="#观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式" class="headerlink" title="观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"></a>观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式</h6></li>
<li><h6 id="适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"><a href="#适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？" class="headerlink" title="适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"></a>适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？</h6></li>
<li><h6 id="建造者模式-工厂模式：要求会手写"><a href="#建造者模式-工厂模式：要求会手写" class="headerlink" title="建造者模式+工厂模式：要求会手写"></a>建造者模式+工厂模式：要求会手写</h6></li>
<li><h6 id="策略模式：这个问得比较少，不过有些做电商的会问。"><a href="#策略模式：这个问得比较少，不过有些做电商的会问。" class="headerlink" title="策略模式：这个问得比较少，不过有些做电商的会问。"></a>策略模式：这个问得比较少，不过有些做电商的会问。</h6></li>
<li><h6 id="MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"><a href="#MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行" class="headerlink" title="MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"></a>MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行</h6><p>阅读 《Android源码设计模式》最后一章483~892</p>
</li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><h6 id="HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，"><a href="#HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，" class="headerlink" title="HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，"></a>HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，</h6><p>很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。<br><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="http://bijian1013.iteye.com/blog/1998847" target="_blank" rel="noopener">HashMap的实现原理详解</a></p>
</li>
<li><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><ol>
<li><h6 id="什么时候会使用HashMap？他有什么特点？"><a href="#什么时候会使用HashMap？他有什么特点？" class="headerlink" title="什么时候会使用HashMap？他有什么特点？"></a>什么时候会使用HashMap？他有什么特点？</h6>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着<strong>Entry(hash, key, value, next)</strong>对象。</li>
<li><h6 id="你知道HashMap的工作原理吗？"><a href="#你知道HashMap的工作原理吗？" class="headerlink" title="你知道HashMap的工作原理吗？"></a>你知道HashMap的工作原理吗？</h6><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1524205439643&amp;di=a5edd509b8a7945fc4ffbd20aed67db3&amp;imgtype=0&amp;src=http%3A%2F%2Fs1.knowsky.com%2F20170221%2Fvbru5sfvszb03.png" alt=""><br><strong>HashMap底层是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组，Entry就是数组中的元素，每个 Map.Entry 是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表</strong>。<br>利用hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍); 如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速。。获取对象时，我们将K传给get，它调用hashCode计算hash获得bucket位置，并进一步调用equals()方法确定键值对。</p>
</li>
<li><h6 id="你知道get和put的原理吗？equals-和hashCode-的都有什么作用？"><a href="#你知道get和put的原理吗？equals-和hashCode-的都有什么作用？" class="headerlink" title="你知道get和put的原理吗？equals()和hashCode()的都有什么作用？"></a>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</h6><p>通过对key的hashCode()进行hash，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
</li>
<li><h6 id="你知道hash的实现吗？为什么要这样实现？"><a href="#你知道hash的实现吗？为什么要这样实现？" class="headerlink" title="你知道hash的实现吗？为什么要这样实现？"></a>你知道hash的实现吗？为什么要这样实现？</h6><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
</li>
<li><h6 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h6><p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
</li>
</ol>
</li>
<li><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p><img src="/2018/04/19/Android开发艺术探索总结/LinkedHashMap.png" alt=""><br><img src="https://img-blog.csdn.net/20170512155609530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong>HashMap是无序的，也就是说，迭代HashMap所得到的元素顺序并不是它们最初放置到HashMap的顺序.</strong></p>
<p><strong>基于HashMap的LinkedHashMap通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序。该迭代顺序可以是插入顺序或者是访问顺序</strong>。</p>
<p><strong>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用 外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。</strong></p>
<ul>
<li>Key和Value都允许空</li>
<li>Key重复会覆盖、Value允许重复</li>
<li>LinkedHashMap是否有序</li>
<li>LinkedHashMap是非线程安全</li>
</ul>
</li>
<li><h6 id="ArrayList和LinkedList对比。"><a href="#ArrayList和LinkedList对比。" class="headerlink" title="ArrayList和LinkedList对比。"></a>ArrayList和LinkedList对比。</h6><p><a href="https://juejin.im/post/59cc5559f265da064b47112f" target="_blank" rel="noopener">Java关于数据结构的实现：表、栈与队列&amp;ArrayList和LinkedList实现原理</a></p>
<p>ArrayList是以数组为基础实现的线性数据结构，具体说来，它有以下特点：</p>
<ul>
<li>快速查找，在物理内存上采用顺序存储结构，可以根据索引进行快速定位查找。</li>
<li>容量动态增长：当数组容量不够用时，创建一个比原来更大的数组，将原来数组的元素复制到新数组中。</li>
<li>可以插入null</li>
<li>没有做同步，非线程安全</li>
</ul>
<p>LinkedList基于双向链表实现的，它具有以特点：</p>
<ul>
<li>基于双向链表实现，可以作为链表使用，也可以作为栈、队列和双端队列使用。</li>
<li>快速插入和删除，在物理内存上存储结构是不连续的；</li>
<li>没有做同步，非线程安全</li>
</ul>
<p><strong>总结</strong><br>以操场上站一群人为例，ArrayList是从头到尾排成队的一堆人，只要知道某个人的位置index，startIndex+offest就能快速定位某个人；LinkedList是一堆特殊的人，他们每个人只知道自己前面是谁，后面是谁，除第一和最后一个外，如果想找到某人，必须一个一个依次往下找。</p>
</li>
<li><h6 id="平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"><a href="#平衡二叉树、二叉查找树、红黑树，这几个我也被考到。" class="headerlink" title="平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"></a>平衡二叉树、二叉查找树、红黑树，这几个我也被考到。</h6><p><a href="https://juejin.im/post/59cc55b95188250b4007539b" target="_blank" rel="noopener">Java关于数据结构的实现：树</a></p>
</li>
<li><h6 id="HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"><a href="#HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。" class="headerlink" title="HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"></a>HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。</h6><p><a href="https://www.cnblogs.com/duanxz/p/3710690.html" target="_blank" rel="noopener">常见hash算法的原理</a></p>
<p><strong>HashSet是基于 HashMap 实现的，底层采用 HashMap 来保存元素,将元素作为key</strong></p>
<ul>
<li><p><strong>对于HashSet及其子类而言，它们采用hash算法来决定集合中元素的存储位置，并通过hash算法来控制集合的大小，且元素不允许重复</strong>；</p>
</li>
<li><p><strong>对于HashMap、Hashtable及其子类而言，它们采用hash算法来觉得Map中key的存储，并通过hash算法来增加key集合的大小</strong>。</p>
</li>
</ul>
<p><img src="/2018/04/19/Android开发艺术探索总结/HashSet.png" alt=""></p>
<p>hash表里可以存储元素的位置被称为“桶(bucket)”，在通常情况下，单个“桶”里存储一个元素时，此时拥有最好的性能：hash算法可以根据hashCode值计算出“桶”的存储位置，接着从“桶”中取出元素。但hash表的状态是open的：在发生“hash冲突”的情况下，单个桶会存储多个元素，这些元素以链表形式存储，必须按顺序搜索。</p>
<p>因为HashSet和HashMap、Hashtable都使用hash算法来决定其元素（HashMap则只考虑key）的存储，因此HashSet、HashMap的hash表中包含如下属性。</p>
<p><strong>容量（capacity）</strong>：hash表中桶的数量<br><strong>初始化容量（inital capacity）</strong>：创建hash表时桶的数量。HashMap和HashSet都允许在构造器中指定初始化容量。<br><strong>尺寸（size</strong>）：当前hash表中记录的数量。<br><strong>负载因子（load factor）</strong>：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的hash表，依次类推。轻负载的hash表具有冲突少，适宜插入与查询的特点（但是用Iterator迭代元素时比较慢）。</p>
</li>
</ol>
<ol start="5">
<li><h6 id="缓存淘汰策略-Lru"><a href="#缓存淘汰策略-Lru" class="headerlink" title="缓存淘汰策略(Lru)"></a>缓存淘汰策略(Lru)</h6></li>
</ol>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li><h6 id="常用的几种算法"><a href="#常用的几种算法" class="headerlink" title="常用的几种算法"></a>常用的几种算法</h6><p><a href="https://juejin.im/post/59fbe7766fb9a0451c39bf21" target="_blank" rel="noopener">排序算法总结</a></p>
</li>
</ol>
<h4 id="热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的"><a href="#热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的" class="headerlink" title="热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)"></a>热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)</h4><p><a href="https://www.jianshu.com/p/704cac3eb13d" target="_blank" rel="noopener">Android 插件化和热修复知识梳理</a><br><a href="https://blog.csdn.net/lmj623565791/article/details/75000580" target="_blank" rel="noopener"> 滴滴插件化方案 VirtualApk 源码解析</a><br><a href="https://blog.csdn.net/lmj623565791/article/details/52761658" target="_blank" rel="noopener">Android 增量更新完全解析 是增量不是热修复</a></p>
<h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>项目中多多少少会用到开源框架，很多公司都喜欢问原理和是否看过源码，比如网络框架Okhttp，这是最常用的，现在Retrofit+RxJava也很流行。</p>
<ol>
<li><h5 id="网络框架库-Okhttp"><a href="#网络框架库-Okhttp" class="headerlink" title="网络框架库 Okhttp"></a>网络框架库 Okhttp</h5><p>okhttp源码一定要去看下，里面几个关键的类要记住，还有连接池，拦截器都需要理解。被问到如何给某些特定域名的url增加header，如果是自己封装的代码，可以在封装Request中可以解决，也可以增加拦截器，通过拦截器去做。</p>
<p>推荐一篇讲解<a href="https://juejin.im/post/5a704ed05188255a8817f4c9" target="_blank" rel="noopener">Okhttp</a>不错的文章<br><a href="https://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="noopener">Android OkHttp完全解析 是时候来了解OkHttp了</a></p>
</li>
<li><h5 id="消息通知-EventBus"><a href="#消息通知-EventBus" class="headerlink" title="消息通知 EventBus"></a>消息通知 EventBus</h5><h6 id="EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射"><a href="#EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射" class="headerlink" title="EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射"></a>EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射</h6><p> EventBus 是Android上的以发布\订阅事件为核心的库。事件 (event) 通过 post() 发送到总线，然后再分发到匹配事件类型的订阅者 (subscribers) 。订阅者只有在总线中注册 (register) 了才能收到事件，注销 (unrigister) 之后就收不到任何事件了。事件方法必须带有 Subscribe 的注解，必须是 public ，没有返回类型 void 并且只能有一个参数。</p>
<p> 详见文章<a href="https://juejin.im/post/5ab9fb4951882521d6579830" target="_blank" rel="noopener">EventBus</a></p>
<h6 id="EventBus可否跨进程问题？代替EventBus的方法（RxBus）"><a href="#EventBus可否跨进程问题？代替EventBus的方法（RxBus）" class="headerlink" title="EventBus可否跨进程问题？代替EventBus的方法（RxBus）"></a>EventBus可否跨进程问题？代替EventBus的方法（RxBus）</h6><p> <a href="https://juejin.im/post/59f93349f265da43085d5727" target="_blank" rel="noopener"> 全方位解析BroadcastReceiver,对比EventBus!</a><br> <a href="https://blog.csdn.net/riley_zhang/article/details/53127042" target="_blank" rel="noopener">BroadcastReceiver、EventBus的优缺点及使用场景</a><br> <a href="https://www.jianshu.com/p/669eda5dc5a4" target="_blank" rel="noopener">RxBus真的能替代EventBus吗？</a></p>
</li>
<li><h5 id="图片加载库（Fresco、Glide、Picasso）"><a href="#图片加载库（Fresco、Glide、Picasso）" class="headerlink" title="图片加载库（Fresco、Glide、Picasso）"></a>图片加载库（Fresco、Glide、Picasso）</h5><h6 id="项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"><a href="#项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别" class="headerlink" title="项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"></a>项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别</h6><p><a href="https://juejin.im/post/5a7568825188257a7a2d9ddb" target="_blank" rel="noopener">Fresco</a><br><a href="https://www.jianshu.com/p/7ce7b02988a4" target="_blank" rel="noopener">Glide</a><br><a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html" target="_blank" rel="noopener">Glide 对比 Picasso</a></p>
<h6 id="项目中选择图片库它的原理，"><a href="#项目中选择图片库它的原理，" class="headerlink" title="项目中选择图片库它的原理，"></a>项目中选择图片库它的原理，</h6><p>如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5.0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？</p>
<p><a href="https://juejin.im/post/5a6da6e7f265da3e303cbcb6" target="_blank" rel="noopener">Android开源框架源码鉴赏：LruCache与DiskLruCache</a></p>
</li>
</ol>
<h4 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h4><ol>
<li><h5 id="RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。"><a href="#RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。" class="headerlink" title="RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。"></a>RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。</h5></li>
<li><h5 id="Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。"><a href="#Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。" class="headerlink" title="Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。"></a>Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。</h5></li>
<li><h5 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h5></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/12/Java集合/" rel="next" title="Java集合">
                <i class="fa fa-chevron-left"></i> Java集合
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/20/Java数据类型和运算符/" rel="prev" title="Java数据类型和运算符">
                Java数据类型和运算符 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yyg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/985211yygg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2289201033@qq.com" target="_blank" title="QQ-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>QQ-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-Fragment-的生命周期和启动模式"><span class="nav-number">1.</span> <span class="nav-text">Activity(Fragment)的生命周期和启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#生命周期分析"><span class="nav-number">1.1.</span> <span class="nav-text">生命周期分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#典型的生命周期"><span class="nav-number">1.1.1.</span> <span class="nav-text">典型的生命周期</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异常情况下的生命周期分析及一些思考问题"><span class="nav-number">1.2.</span> <span class="nav-text">异常情况下的生命周期分析及一些思考问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity是如何保存和恢复View的结构？"><span class="nav-number">1.3.</span> <span class="nav-text">Activity是如何保存和恢复View的结构？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#资源不足导致低优先级的activity被杀死"><span class="nav-number">1.4.</span> <span class="nav-text">资源不足导致低优先级的activity被杀死</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#问题"><span class="nav-number">1.5.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Android的启动模式"><span class="nav-number">1.6.</span> <span class="nav-text">Android的启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#activity的startActivity和context的startActivity区别"><span class="nav-number">1.6.1.</span> <span class="nav-text">activity的startActivity和context的startActivity区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Acticity和Fragment的通信方式"><span class="nav-number">1.7.</span> <span class="nav-text">Acticity和Fragment的通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信IPC机制"><span class="nav-number">2.</span> <span class="nav-text">进程间通信IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是IPC？"><span class="nav-number">2.1.</span> <span class="nav-text">什么是IPC？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是多进程？"><span class="nav-number">2.2.</span> <span class="nav-text">什么是多进程？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#如何开启多进程？"><span class="nav-number">2.2.1.</span> <span class="nav-text">如何开启多进程？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#多进程的运行机制？"><span class="nav-number">2.2.2.</span> <span class="nav-text">多进程的运行机制？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#进程隔离"><span class="nav-number">2.2.3.</span> <span class="nav-text">进程隔离</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Android-Binder跨进程通信的原理"><span class="nav-number">2.3.</span> <span class="nav-text">Android Binder跨进程通信的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Binder是什么？"><span class="nav-number">2.3.1.</span> <span class="nav-text">Binder是什么？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Binder跨进程通信原理"><span class="nav-number">2.3.2.</span> <span class="nav-text">Binder跨进程通信原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#各个模块的作用："><span class="nav-number">2.3.3.</span> <span class="nav-text">各个模块的作用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ServerManager是如何管理server的？"><span class="nav-number">2.3.4.</span> <span class="nav-text">ServerManager是如何管理server的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#跨进程通信的核心原理"><span class="nav-number">2.3.5.</span> <span class="nav-text">跨进程通信的核心原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder通信原理图："><span class="nav-number">2.4.</span> <span class="nav-text">Binder通信原理图：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Android的中IPC方式对比"><span class="nav-number">2.5.</span> <span class="nav-text">Android的中IPC方式对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的事件体系"><span class="nav-number">3.</span> <span class="nav-text">View的事件体系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View的滑动"><span class="nav-number">3.1.</span> <span class="nav-text">View的滑动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件拦截和分发"><span class="nav-number">3.2.</span> <span class="nav-text">事件拦截和分发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#View的滑动冲突"><span class="nav-number">3.3.</span> <span class="nav-text">View的滑动冲突</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的工作原理"><span class="nav-number">4.</span> <span class="nav-text">View的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View的绘制流程："><span class="nav-number">4.1.</span> <span class="nav-text">View的绘制流程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#view的工作流程："><span class="nav-number">4.2.</span> <span class="nav-text">view的工作流程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义View"><span class="nav-number">4.3.</span> <span class="nav-text">自定义View</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#自定义View的分类及流程："><span class="nav-number">4.3.1.</span> <span class="nav-text">自定义View的分类及流程：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#直接继承view或者ViewGroup的控件，有时候warp-content达不到预期效果？"><span class="nav-number">4.3.2.</span> <span class="nav-text">直接继承view或者ViewGroup的控件，有时候warp_content达不到预期效果？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#自定义View注意事项"><span class="nav-number">4.3.3.</span> <span class="nav-text">自定义View注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android动画分析"><span class="nav-number">5.</span> <span class="nav-text">Android动画分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Android动画分类：view动画，属性动画和新增的物理动画"><span class="nav-number">5.1.</span> <span class="nav-text">Android动画分类：view动画，属性动画和新增的物理动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义view动画的及其使用场景"><span class="nav-number">5.2.</span> <span class="nav-text">自定义view动画的及其使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#自定义view动画"><span class="nav-number">5.2.1.</span> <span class="nav-text">自定义view动画</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性动画："><span class="nav-number">5.3.</span> <span class="nav-text">属性动画：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#属性动画的工作原理："><span class="nav-number">5.3.1.</span> <span class="nav-text">属性动画的工作原理：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用动画的注意事项："><span class="nav-number">5.4.</span> <span class="nav-text">使用动画的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解Window和WinowManager"><span class="nav-number">6.</span> <span class="nav-text">理解Window和WinowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述："><span class="nav-number">6.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Window的内部机制"><span class="nav-number">6.2.</span> <span class="nav-text">Window的内部机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"><span class="nav-number">6.3.</span> <span class="nav-text">PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity的视图创建过程"><span class="nav-number">6.4.</span> <span class="nav-text">Activity的视图创建过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四大组件的工作过程"><span class="nav-number">7.</span> <span class="nav-text">四大组件的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity的工作过程"><span class="nav-number">7.2.</span> <span class="nav-text">Activity的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#activity是如何启动？"><span class="nav-number">7.2.1.</span> <span class="nav-text">activity是如何启动？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Service的工作过程"><span class="nav-number">7.3.</span> <span class="nav-text">Service的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Service的启动过程和绑定过程"><span class="nav-number">7.3.1.</span> <span class="nav-text">Service的启动过程和绑定过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何保证Service不被杀死？"><span class="nav-number">7.3.2.</span> <span class="nav-text">如何保证Service不被杀死？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#怎么在Service中创建Dialog对话框"><span class="nav-number">7.3.3.</span> <span class="nav-text">怎么在Service中创建Dialog对话框</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的消息机制"><span class="nav-number">8.</span> <span class="nav-text">Android的消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述：-1"><span class="nav-number">8.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消息机制原理"><span class="nav-number">8.2.</span> <span class="nav-text">消息机制原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">8.3.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"><span class="nav-number">8.4.</span> <span class="nav-text">在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#只能在主线程中更新UI，这种说法对吗？"><span class="nav-number">8.5.</span> <span class="nav-text">只能在主线程中更新UI，这种说法对吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handler导致的内存泄漏"><span class="nav-number">8.6.</span> <span class="nav-text">Handler导致的内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么一个线程只有一个Looper、只有一个MessageQueue？"><span class="nav-number">8.7.</span> <span class="nav-text">为什么一个线程只有一个Looper、只有一个MessageQueue？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的线程和线程池"><span class="nav-number">9.</span> <span class="nav-text">Android的线程和线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主线程和子线程"><span class="nav-number">9.1.</span> <span class="nav-text">主线程和子线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Android中的线程形态"><span class="nav-number">9.2.</span> <span class="nav-text">Android中的线程形态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HandlerThread、IntentService理解"><span class="nav-number">9.3.</span> <span class="nav-text">HandlerThread、IntentService理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android中的线程池"><span class="nav-number">9.4.</span> <span class="nav-text">android中的线程池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bitmap的加载和缓存"><span class="nav-number">10.</span> <span class="nav-text">Bitmap的加载和缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bitmap的高效加载"><span class="nav-number">10.1.</span> <span class="nav-text">Bitmap的高效加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高效加载大图"><span class="nav-number">10.2.</span> <span class="nav-text">高效加载大图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android的缓存策略"><span class="nav-number">10.3.</span> <span class="nav-text">android的缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#android图片的三级缓存"><span class="nav-number">10.3.1.</span> <span class="nav-text">android图片的三级缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的性能优化"><span class="nav-number">11.</span> <span class="nav-text">Android的性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#布局优化"><span class="nav-number">11.1.</span> <span class="nav-text">布局优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄露优化"><span class="nav-number">11.2.</span> <span class="nav-text">内存泄露优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#绘制优化"><span class="nav-number">11.3.</span> <span class="nav-text">绘制优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程优化"><span class="nav-number">11.4.</span> <span class="nav-text">线程优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#响应速度优化和ANR日志分析"><span class="nav-number">11.5.</span> <span class="nav-text">响应速度优化和ANR日志分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ListView和Bitmap优化"><span class="nav-number">11.6.</span> <span class="nav-text">ListView和Bitmap优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP"><span class="nav-number">12.</span> <span class="nav-text">TCP和UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简述TCP建立连接的三次握手及原因？"><span class="nav-number">12.1.</span> <span class="nav-text">简述TCP建立连接的三次握手及原因？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP四次分手"><span class="nav-number">12.2.</span> <span class="nav-text">TCP四次分手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么客户端关闭连接前要等待2MSL时间？"><span class="nav-number">12.3.</span> <span class="nav-text">为什么客户端关闭连接前要等待2MSL时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DDoS攻击"><span class="nav-number">12.4.</span> <span class="nav-text">DDoS攻击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http-Https"><span class="nav-number">13.</span> <span class="nav-text">Http/Https</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java垃圾回收机制"><span class="nav-number">14.</span> <span class="nav-text">Java垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM"><span class="nav-number">15.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载机制"><span class="nav-number">16.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java的四种引用类型"><span class="nav-number">17.</span> <span class="nav-text">Java的四种引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int、Integer有什么区别"><span class="nav-number">18.</span> <span class="nav-text">int、Integer有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态权限适配问题、换肤实现原理"><span class="nav-number">19.</span> <span class="nav-text">动态权限适配问题、换肤实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SharedPreference原理，能否跨进程？如何实现？"><span class="nav-number">20.</span> <span class="nav-text">SharedPreference原理，能否跨进程？如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应速度优化"><span class="nav-number">21.</span> <span class="nav-text">响应速度优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设计模式"><span class="nav-number">22.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"><span class="nav-number">22.0.1.</span> <span class="nav-text">单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"><span class="nav-number">22.0.2.</span> <span class="nav-text">观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"><span class="nav-number">22.0.3.</span> <span class="nav-text">适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#建造者模式-工厂模式：要求会手写"><span class="nav-number">22.0.4.</span> <span class="nav-text">建造者模式+工厂模式：要求会手写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#策略模式：这个问得比较少，不过有些做电商的会问。"><span class="nav-number">22.0.5.</span> <span class="nav-text">策略模式：这个问得比较少，不过有些做电商的会问。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"><span class="nav-number">22.0.6.</span> <span class="nav-text">MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">23.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，"><span class="nav-number">23.0.1.</span> <span class="nav-text">HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap"><span class="nav-number">23.1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#什么时候会使用HashMap？他有什么特点？"><span class="nav-number">23.1.1.</span> <span class="nav-text">什么时候会使用HashMap？他有什么特点？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#你知道HashMap的工作原理吗？"><span class="nav-number">23.1.2.</span> <span class="nav-text">你知道HashMap的工作原理吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#你知道get和put的原理吗？equals-和hashCode-的都有什么作用？"><span class="nav-number">23.1.3.</span> <span class="nav-text">你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#你知道hash的实现吗？为什么要这样实现？"><span class="nav-number">23.1.4.</span> <span class="nav-text">你知道hash的实现吗？为什么要这样实现？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><span class="nav-number">23.1.5.</span> <span class="nav-text">如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">23.2.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ArrayList和LinkedList对比。"><span class="nav-number">23.2.1.</span> <span class="nav-text">ArrayList和LinkedList对比。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"><span class="nav-number">23.2.2.</span> <span class="nav-text">平衡二叉树、二叉查找树、红黑树，这几个我也被考到。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"><span class="nav-number">23.2.3.</span> <span class="nav-text">HashSet原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缓存淘汰策略-Lru"><span class="nav-number">23.2.4.</span> <span class="nav-text">缓存淘汰策略(Lru)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法"><span class="nav-number">24.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#常用的几种算法"><span class="nav-number">24.0.1.</span> <span class="nav-text">常用的几种算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的"><span class="nav-number">25.</span> <span class="nav-text">热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码理解"><span class="nav-number">26.</span> <span class="nav-text">源码理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#网络框架库-Okhttp"><span class="nav-number">26.1.</span> <span class="nav-text">网络框架库 Okhttp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消息通知-EventBus"><span class="nav-number">26.2.</span> <span class="nav-text">消息通知 EventBus</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射"><span class="nav-number">26.2.1.</span> <span class="nav-text">EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EventBus可否跨进程问题？代替EventBus的方法（RxBus）"><span class="nav-number">26.2.2.</span> <span class="nav-text">EventBus可否跨进程问题？代替EventBus的方法（RxBus）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图片加载库（Fresco、Glide、Picasso）"><span class="nav-number">26.3.</span> <span class="nav-text">图片加载库（Fresco、Glide、Picasso）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"><span class="nav-number">26.3.1.</span> <span class="nav-text">项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#项目中选择图片库它的原理，"><span class="nav-number">26.3.2.</span> <span class="nav-text">项目中选择图片库它的原理，</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新技术"><span class="nav-number">27.</span> <span class="nav-text">新技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。"><span class="nav-number">27.1.</span> <span class="nav-text">RxJava、RxBus、RxAndroid，这个在面试想去的公司时，可以反编译下他们的包，看下是不是用到，如果用到了，面试过程难免会问道，如果没有，也可以忽略，但学习心强的同学可以看下，比较是比较火的框架。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。"><span class="nav-number">27.2.</span> <span class="nav-text">Retrofit，熟练okhttp的同学建议看下，听说结合RxJava很爽。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kotlin"><span class="nav-number">27.3.</span> <span class="nav-text">Kotlin</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyg</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
