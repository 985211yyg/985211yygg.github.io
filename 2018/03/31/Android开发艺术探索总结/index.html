<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期      fragment的生命周期   与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然提供了就有">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索总结">
<meta property="og:url" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/index.html">
<meta property="og:site_name" content="yyg的小黑屋">
<meta property="og:description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期      fragment的生命周期   与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然提供了就有">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_launch_mode.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-c10d6032f91a103f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/Binder_module-table.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/IPC.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/android_view_hierarchy.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/motion_event_method.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/Window的内部机制.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity启动流程.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/service_lifecycle.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/dialog.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/Handler消息机制.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/TCP_shake_hands_LI.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/TCP_wave_hands.png">
<meta property="og:updated_time" content="2018-04-13T02:55:23.946Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索总结">
<meta name="twitter:description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期      fragment的生命周期   与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然提供了就有">
<meta name="twitter:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/"/>





  <title>Android开发艺术探索总结 | yyg的小黑屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyg的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yyg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyg的小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T08:45:47+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Activity-Fragment-的生命周期和启动模式"><a href="#Activity-Fragment-的生命周期和启动模式" class="headerlink" title="Activity(Fragment)的生命周期和启动模式"></a>Activity(Fragment)的生命周期和启动模式</h4><h5 id="1-1-生命周期分析"><a href="#1-1-生命周期分析" class="headerlink" title="1.1 生命周期分析"></a>1.1 <strong>生命周期分析</strong></h5><ul>
<li><p>1.1.1 <strong>典型的生命周期</strong></p>
<ul>
<li><blockquote>
<p><strong>activity的生命周期</strong></p>
</blockquote>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG" alt=""></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_lifecycle_table.PNG" alt=""></p>
</li>
<li><blockquote>
<p><strong>fragment的生命周期</strong></p>
</blockquote>
<p><img src="/2018/03/31/Android开发艺术探索总结/fragment_lifecycle.png" alt=""></p>
<p><strong>与宿主Activity的生命周期的关系</strong></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle.png" alt=""></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG" alt=""></p>
<ul>
<li><blockquote>
<p><strong>onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？</strong></p>
</blockquote>
</li>
</ul>
<p>对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop是从activity这个角度来回调的，此时是无法操作的 ; onResume和onPause是从activity是否位于前台来回调，此时由可操作变为不克操作。</p>
</li>
</ul>
<ul>
<li><p>1.1.2 <strong>异常情况下的生命周期分析及一些思考问题</strong></p>
<ul>
<li><blockquote>
<p><strong>横竖屏切换时Activity的异常生命周期变化?</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">      Activity创建：</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      竖屏切横屏：</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">      onPause--&gt;</span><br><span class="line">      onStop--&gt;</span><br><span class="line">      onDestroy--&gt;</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onRestoreInstanceState--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      横屏切换竖屏</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br><span class="line">onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br></pre></td></tr></table></figure>
<p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>
<p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>
<p>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<p>4、补充：Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop;重新回到Activity=： onRestart –&gt;onStart—&gt;onResume<br>  Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</p>
<ul>
<li><blockquote>
<p><strong> Activity是如何保存和恢复View的结构？</strong></p>
</blockquote>
</li>
</ul>
<p>首先，activity被意外终止时，activity会调用onSaveInstanceState()去保存数据，然后activity会委托Window去保存数据，接着window委托它的上级容器去保存数据。顶级容器是一个ViewGroup，一般可能是是DecorView。最后顶级容器再去一一通知子元素去保存数据，对于数据的恢复也是类似的。</p>
<ul>
<li><blockquote>
<p><strong>资源不足导致低优先级的activity被杀死 </strong></p>
</blockquote>
</li>
</ul>
<p>activity的优先级：<br>1.<code>前台activity</code>——正在和用户交互的activity，优先级最高<br>2.<code>可见但非前台activity</code>—–比如activity中弹出一个对话框，导致activity可见但是位于后台无法与直接交互。<br>3.<code>后台activity</code>—-已经被暂停的activity，比如执行了onStop(),优先级最低</p>
<p>对于系统内存不足时，系统会按照优先级来杀死目标activity的进程，然后通过onSaveInstanceState()和onRestoreInstanceState()存储恢复数据。</p>
<ul>
<li><blockquote>
<p><strong>假设当前activity为A,若此时用户打开activity B，那么 B 的onResume()和 A 的OnPause()那个先执行？</strong></p>
</blockquote>
</li>
</ul>
<p>当新启动一个activity时，位于栈顶的旧activity的onPause()会先执行，才会启动新的activity，另外Android对onPause()的解释是不能在其中进行重量级的操作，为了新的activity尽快出现在前台，所以资源回收等重量尽量在onStop()中进行，这也能说明onRsume()先执行。</p>
<ul>
<li><blockquote>
<p><strong> 通过 addToBackStack() 将 Fragment 放入回退栈，然后通过 popBackStack() 出栈，Fragment 的生命周期会如何变化呢？2. 如果 Fragment 与 ViewPager 结合使用，Fragment 的生命周期又是如何？3. 如果通过 hide() 和 show() 方法来展示隐藏，这时 Fragment 的生命周期又会如何？</strong></p>
</blockquote>
</li>
</ul>
<p>1.第一点很重要，最开始的两张图展示的 Fragment 与 Activity 的生命周期关系没毛病。</p>
<p>2.onAttach() 和 onCreate() 只在 Fragment 与 Activity 第一次关联时调用。</p>
<p>3.onDestroy() 和 onDetach() 只在 Fragment 的宿主 Activity 销毁时才会被调用。</p>
<p>4.根据前 3 点，将 Fragment 通过 addToBackStack() 只涉及 onCreateView() 和 onDestroyView() 这之间的生命周期。add() 和 replace() 不会对 Fragment 的生命周期产生影响，但 add() 方法会造成 Fragment 叠加显示。</p>
<p>5.Fragment 与 ViewPager 结合使用时的生命周期与第 4 点相似。</p>
<p>6.通过 hide() 、 show() 来隐藏、显示Fragment，此时 Fragment 只改变了可见性，并不涉及生命周期的改变</p>
<p>7.第 7 点与Fragment 和 Activity 的生命周期有关，即：不要在 Fragment 的 onCreate() 方法中操作宿主Activity 的 UI。因为你无法保证此时 宿主Activity 的 UI 已经完全初始化。PS:某些情况下是可以确保 宿主Activity 已经初始化完成的。</p>
<h5 id="1-2-Android的启动模式"><a href="#1-2-Android的启动模式" class="headerlink" title="1.2 Android的启动模式"></a>1.2 Android的启动模式</h5><p><img src="/2018/03/31/Android开发艺术探索总结/activity_launch_mode.PNG" alt=""></p>
<ul>
<li><blockquote>
<p><strong> activity的startActivity和context的startActivity区别</strong></p>
</blockquote>
<p>(1) 从Activity中启动新的Activity时可以直接mContext.startActivity(intent)就好，<br>(2) 如果从其他Context中启动Activity则必须给intent设置Flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK) ;</span><br><span class="line">mContext.startActivity(intent);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-Acticity和Fragment的通信方式"><a href="#1-3-Acticity和Fragment的通信方式" class="headerlink" title="1.3 Acticity和Fragment的通信方式"></a>1.3 Acticity和Fragment的通信方式</h5></li>
</ul>
<h4 id="进程间通信IPC机制"><a href="#进程间通信IPC机制" class="headerlink" title="进程间通信IPC机制"></a>进程间通信IPC机制</h4><ol>
<li><h5 id="什么是IPC？"><a href="#什么是IPC？" class="headerlink" title="什么是IPC？"></a>什么是IPC？</h5>IPC,Inter-Process Communication的缩写，含义为进程通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br><code>**线程**：</code>cup调度的最小单位<br><code>**进程**：</code>一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。<br><code>**ANR**:</code>在主线程中进行大量的耗时操作导致界面无法响应。</li>
<li><h5 id="什么是多进程？"><a href="#什么是多进程？" class="headerlink" title="什么是多进程？"></a>什么是多进程？</h5><ul>
<li><blockquote>
<p><strong>如何开启多进程？</strong></p>
</blockquote>
<p>Android中只有一种方式开启多进程，就是在四大组件的啊AndroidMenifest中指定android:process属性。</p>
</li>
<li><blockquote>
<p><strong>多进程的运行机制？</strong></p>
</blockquote>
<p>开启多进程造成的问题：</p>
<ul>
<li>静态成员和单列模式完成失效</li>
<li>线程同步机制失效</li>
<li>SharePreferences的可靠性失效</li>
<li>Application会多次创建</li>
</ul>
</li>
<li><blockquote>
<p><strong>进程隔离</strong></p>
</blockquote>
<p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即Android的进程是<code>相互独立</code>、<code>隔离的</code></p>
</li>
</ul>
<h5 id="2-3-Android-Binder跨进程通信的原理"><a href="#2-3-Android-Binder跨进程通信的原理" class="headerlink" title="2.3 Android Binder跨进程通信的原理"></a>2.3 Android Binder跨进程通信的原理</h5><ul>
<li><blockquote>
<p><strong>Binder是什么？</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br><strong>说人话—-</strong></p>
<ul>
<li><p><code>直观角度</code>：Binder是Android的一个类，实现了IBinder接口</p>
</li>
<li><p><code>IPC角度</code>：Binder是Android一种跨进程通信的方式</p>
</li>
<li><p><code>Android Framework角度</code>: Binder是<code>ServiceManager</code>连接各        种Manager(<code>ActivityManager</code>、<code>WindowManger</code>)和相应ManagerService的桥梁</p>
</li>
<li><p><code>android应用层角度</code>：Binder是客户端和服务端进行通信的媒介。binderService的时候服务端会返回一个包含服务端业务调用的Binder对象，通过这个binder对象客户端可以获取服务端提供的服务和数据(包含该普通服务和基于AIDL的服务)</p>
</li>
</ul>
</li>
<li><blockquote>
<p><strong>Binder跨进程通信原理</strong></p>
</blockquote>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-c10d6032f91a103f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="通信原理图"></p>
<p><strong>各个模块的作用</strong>：<br><img src="/2018/03/31/Android开发艺术探索总结/Binder_module-table.PNG" alt="各模块的作用"></p>
<ul>
<li><blockquote>
<p><strong>ServerManager是如何管理server的？</strong></p>
</blockquote>
<ul>
<li><p><strong>Binder Client 通过ServerManager获取Binder的引用，binder的引用是由SeverManager转换或者说映射得到的</strong>。</p>
</li>
<li><p><strong>Binder Server在生成一个Binder实体的同时会为其绑定一个名字，并将这个名字封装成一个数据包传递给Binder Driver</strong>；</p>
</li>
<li><p><strong>Binder Driver接收到数据包之后，如果是新的Binder，会为它在内存空间中创建相应的实体节点和一个对实体节点的引用，在源码中中分别对应Binder_node和Binder_ref；创建完后，Binder Driver 会将该引用传递给ServerManager;</strong></p>
</li>
<li><p><strong>ServerManager接收到之后会从中取出该Binder的名字和引用然后插入到一个数据表中，如此形成了类似DNS中存储的域名到真实IP的映射，然后Binder Client就可利用ServerManager通过名字查询Binder的引用，获取服务</strong>。</p>
</li>
<li><strong>当然Binder并非一定在ServerManager中有记录，很多时候Binder Server会将一个Binder实体封装进数据包传递给Binder Client,此时Binder server会在数据包中标注Binder实体的位置，Binder Driver会为该匿名的Binder生成实体节点和引用，并将引用通过映射传递给Binder Clien </strong></li>
</ul>
</li>
<li><blockquote>
<p><strong>跨进程通信的核心原理</strong></p>
</blockquote>
</li>
</ul>
<p><strong>关于其核心原理：内存映射，具体请看文章：<a href="https://www.jianshu.com/p/719fc4758813" target="_blank" rel="noopener">操作系统：图文详解 内存映射</a> </strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/" alt="Binder Driver"></p>
<p><strong>Binder通信原理图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/" alt="Binder原理图"></p>
<blockquote>
<p><strong>Android的中IPC方式对比</strong></p>
</blockquote>
<p><img src="/2018/03/31/Android开发艺术探索总结/IPC.PNG" alt=""></p>
</li>
</ol>
<h4 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h4><ol>
<li><h5 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h5><ul>
<li>使用scrollTo/scrollBy<br><code>scrollTo</code>:一次性滑动，屏幕左上角坐标为基准<br><code>scrollBy</code>:多次的，相对于当前位置的</li>
<li>使用动画</li>
<li>改变布局参数</li>
</ul>
<ol start="2">
<li><h5 id="事件拦截和分发"><a href="#事件拦截和分发" class="headerlink" title="事件拦截和分发"></a>事件拦截和分发</h5><img src="/2018/03/31/Android开发艺术探索总结/android_view_hierarchy.jpg" alt=""><br><strong>先来一段伪代码简单表示事件的传递规则</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">    boolean cousume = flase;</span><br><span class="line">    //拦截</span><br><span class="line">    if(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">        //消费</span><br><span class="line">       consume = onTouchEvent();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       //子view继续分发事件</span><br><span class="line">       consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    return consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MotionEvent=====&gt;Activty-----&gt;Window(PhoneWindow)-------&gt;DecorView----&gt;</span><br><span class="line">---&gt;顶级View(setContentView()，一般是ViewGroup)-------&gt;目标View</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说人话描述上面这段代码</strong>：</p>
</blockquote>
<p><strong>点击事件产生后，经过Activty,PhoneWindow,DecorView的分发传递，事件会传递给顶级View(一般是ViewGroup)，这时候它的dispatchTouchEvent()方法会被调用，如果内部的onInterceptTouchEvent()方法返回true,则表示它拦截当前的事件，特殊的如果ViewGroup的mOnTouchListener被设置，事件会被onTouch()处理，否则事件就正常交给ViewGroup的onTouchEvent()方法会处理；相反，如果ViewGroup的onInterceptTouchEvent()方法返回出false,则表示不拦截当前的事件，这时当前的事件就会传递它的子元素，接着子元素的dispatchTouchEvent()方法会被调用，如此反复直到事件被处理。</strong></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/motion_event_method.png" alt=""></p>
</li>
<li><h5 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h5><ul>
<li><blockquote>
<p><strong>解决ScrollView嵌套ListView和GridView冲突的方法</strong></p>
</blockquote>
<p>重写ListView的onMeasure方法，来自定义高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"> int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST);</span><br><span class="line"> super.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要考察对MeasureSpec的三种模式的理解,相关文章.</p>
</li>
</ul>
</li>
</ol>
<h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><ol>
<li><h5 id="View的绘制流程："><a href="#View的绘制流程：" class="headerlink" title="View的绘制流程："></a>View的绘制流程：</h5><p>View的绘制是从ViewRoot的performTraversals()方法开始的，该方法会依次调用performMeasure、performLayout、performDraw三个方法，这三个方法依次完成顶级view的measure、layout、draw。其中perform会调用measure方法，在measure中有会调用onMeasure方法，在onMeasure方法中会对所有的子view进行measure，此时整个measure流程从父容器传到了子元素，完成一次measur过程，接着子元素会重复父容器的measure过程，如此反复完成整个view树的遍历。同理performLayout、performDraw与performMeasure的流程是类似的，最终完成view的绘制。</p>
</li>
<li><h5 id="view的工作流程："><a href="#view的工作流程：" class="headerlink" title="view的工作流程："></a>view的工作流程：</h5><p>主要是指measure、layout、draw这三大流程，其中measure确定view的测量宽/高；layout确定view的最终宽/高和四个顶点的位置；二draw将view绘制在屏幕上。</p>
<p>对于view直接调用onMeasure方法来测量，而ViewGroup是抽象类，没有重写onMeasure方法，而是通过measureChildren遍历子元素，通过measureChild方法调用子元素的measure完成测量；</p>
<p>ViewGroup layout的大致流程：通过setFrame方法来设定view的四个顶点的位置，view的四个顶点一单确定view在父容器的中的位置也就确定，接着调用onLaytout确定子元素的位置;</p>
<ul>
<li>Draw遵循步骤：</li>
<li>1、绘制背景background.draw(canvas);</li>
<li>2、绘制自己onDraw;</li>
<li>3、绘制children–dispatchDraw;</li>
<li>4、绘制装饰—onDrawScrollBars.</li>
</ul>
</li>
<li><h5 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h5><p>　<strong>自定义View的分类及流程：</strong></p>
<ul>
<li><p>1、<strong>继承View重写onDraw方法</strong>；需要自己支持warp_content，处理padding；</p>
</li>
<li><p>2、<strong>继承ViewGroup派生特殊的布局</strong>，方法需要适当的处理ViewGroup的测量和布局的两个过程，并同时处理子元素的布局和测量过程。</p>
</li>
<li><p>3、<strong>继承特定的View</strong>，如TextView，对已有的功能进行拓展，无序自己支持warp_content，处理padding</p>
</li>
<li><p>4、<strong>继承特定的ViewGroup</strong>,如线性布局，此方法不需要自己处理ViewGroup的测量和布局。</p>
</li>
<li>5、<strong>为了使自定义的View更易用，还需要添加自定义属性，以便在布局文件中使用：</strong><ul>
<li>1、在values目录中创建自定义属性xml文件，如attrs.在values目录中创建自定义属性xml文件</li>
<li>2、在view的构造方法中解析自定义的属性，并相应的处理，如定义默认值等。</li>
<li>3、在布局文件中声明然后使用。</li>
</ul>
</li>
</ul>
<p><strong>直接继承view或者ViewGroup的控件，有时候warp_content达不到预期效果？</strong><br><code>原因</code>：当view在布局中使用warp_content，此时specMode为AT_MOST，宽高等于specSize，这种情况下View的specSize为parentSize,而parentSized的大小为父容器当前的剩余空间，使得和使用match_parent效果一致。</p>
<p><code>解决方法</code>：给View设定默认的宽/高，并在warp_content时根据情况设置此宽/高，即可。<br><strong>自定义View注意事项</strong></p>
<ul>
<li><p>1.让View支持warp_content</p>
</li>
<li><p>2.如有必要，让view支持padding</p>
</li>
<li><p>3.尽量不要在view中使用Handler,没必要，view本身提供post方法，完全可以替代Handler的作用，除非明确用handler来发送消息。</p>
</li>
<li><p>View中如果有线程或者动画，需要及时停止，View的OnDetachFromWindow是个好时机，当包含此view的Activity退出或者当前的View被remove是，此方法都会被调用。同事view背的不可见时候也需停止动画或者线程，避免内存泄漏。</p>
</li>
<li><p>View带有嵌套滑动的情形是，需要处理滑动冲突。</p>
</li>
</ul>
</li>
</ol>
<h4 id="Android动画分析"><a href="#Android动画分析" class="headerlink" title="Android动画分析"></a>Android动画分析</h4><ol>
<li><h5 id="Android动画分类：view动画，属性动画和新增的物理动画"><a href="#Android动画分类：view动画，属性动画和新增的物理动画" class="headerlink" title="Android动画分类：view动画，属性动画和新增的物理动画"></a>Android动画分类：view动画，属性动画和新增的物理动画</h5><ul>
<li><p><strong>View动画</strong>：对场景里的对象不断做图像变换（平移，缩放，旋转，透明度）从而产生一系列的动画效果，是一种渐进式动画，支持自定义；它包含该两个特殊的类型帧动画和补间动画：</p>
<ul>
<li>帧动画：通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片的切换动画。图片过多过大会导致oom;</li>
<li>补间动画：是帧动画的特殊形式，只需要提供开始图片和结束图片作为开始帧和结束帧，而动画的中间帧由系统计算补充。</li>
</ul>
</li>
<li><p><strong>属性动画</strong>：通过动态的改变对象的属性从而达到动画效果。</p>
</li>
<li><strong>物理动画</strong>：基于物理规律的动画效果。</li>
</ul>
</li>
<li><h5 id="自定义view和view动画的特殊使用场景"><a href="#自定义view和view动画的特殊使用场景" class="headerlink" title="自定义view和view动画的特殊使用场景"></a>自定义view和view动画的特殊使用场景</h5> <strong>自定义view动画</strong><br>   继承Animation抽象类—-&gt;重写initialize和applyTransformation方法—–&gt;在initialize中做初始化工作，在applyTransformation中进行相应的矩阵变换。<ul>
<li><code>view动画的特殊使用场景</code>：在ViewGroup中控制元素的出场效果，实现activity的出场动画。</li>
</ul>
</li>
<li><h5 id="属性动画："><a href="#属性动画：" class="headerlink" title="属性动画："></a>属性动画：</h5><p> 常见的几个动画类：ValueAnimator,ObjectAnimator,AnimatorSet。<br> <code>插值器</code>：根据时间流逝的百分比来计算出当前属性值改变的百分比<br> <code>估值器</code>:根据当前属性变化的百分比计算改变后的属性值</p>
<h5 id="属性动画的工作原理："><a href="#属性动画的工作原理：" class="headerlink" title="属性动画的工作原理："></a>属性动画的工作原理：</h5><p> 在一定时间间隔内和值范围内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。因此要求作用的对象有该属性的set方法，如果没有设置初始值，还需要对象提供get方法，或者进行包装设置getter/setter方法。ValueAnimator不断控制值的变化，然后手动赋值给对象的属性，ObjectAnimator直接操作对象属性的值。</p>
</li>
<li><h5 id="使用动画的注意事项："><a href="#使用动画的注意事项：" class="headerlink" title="使用动画的注意事项："></a>使用动画的注意事项：</h5><p> 1、帧动画中如果使用的图片过多多大容易出现OOM;<br> 2、内存泄漏：属性动画中的无限循环动画需要在activity退出时及时停止，避免activity无法释放造成内存泄漏。<br> 3、尽量使用dp保证在不同设备上的效果；<br> 4、动画元素的交互问题：使用view动画移动之后点击事件还在原地，点击移动后的view无效======这是因为view动画只是对控件影像的操作，到达动画视觉的效果，而控件还留在原来的区域。</p>
</li>
</ol>
<h4 id="理解Window和WinowManager"><a href="#理解Window和WinowManager" class="headerlink" title="理解Window和WinowManager"></a>理解Window和WinowManager</h4><ol>
<li><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>Window表示一个窗口的概念，是一个抽象类，Android的所有视图都通过Window呈现，并依附于它，不管是activity、dialog、还是toast，Window都是view的直接管理者。具体实现是PhoneWindow，通过WindowManager创建window，window的外界访问入口是WindowMananger，具体实现在WindowManagerServer中，因此windowmanger和WindowManagerServer的交互式IPC过程。</p>
</li>
<li><h5 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h5><p><img src="/2018/03/31/Android开发艺术探索总结/Window的内部机制.jpg" alt=""></p>
</li>
<li><h5 id="PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"><a href="#PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？" class="headerlink" title="PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"></a>PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？</h5>以Activity中Window创建为例：在activity的实例创建之后会调用Activity的attach方法，此方法中系统会创建Activity所属的Window对象，Window对象的创建是通过PolicyManager的具体实现类Policy类中的makeNewWindow方法实现的，此方法中放返回一个PhoneWindow的实例。因此此过程就是PhoneWindow的实例化过程，而PhoneWindow是Window的具体实现类。</li>
<li><h5 id="Activity的视图创建过程"><a href="#Activity的视图创建过程" class="headerlink" title="Activity的视图创建过程"></a>Activity的视图创建过程</h5><ol>
<li><p>创建Window:Activity的attach方法中通过PolicyManager的makeNewWindow方法创建实现类PhoneWindow;</p>
</li>
<li><p>初始化DecorView并将定义的布局添加到DecorView的<code>mParentContent</code>中，回调；</p>
</li>
<li><p>DecorView已经初始化完毕，ActivityThread的handleResumeActivity方法调用onResume方法，然后在makeVisible()方法中使activity视图可见。</p>
</li>
</ol>
</li>
</ol>
<h4 id="四大组件的工作过程"><a href="#四大组件的工作过程" class="headerlink" title="四大组件的工作过程"></a>四大组件的工作过程</h4><ol>
<li><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><strong>Activity</strong>：展示型组件，向用户展示界面，接收用户输入进行交互；<br><strong>Service</strong>:计算性组件，在后台执行一系列计算任务；<br><strong>BroadcastReceiver</strong>:消息型组件，应用在不同组件乃至不同应用之间传递消息。可实现低耦合观察者模式；<br><strong>ContentProvider</strong>:数据共享型组件，用于向其他组件乃至应用间共享数据。</p>
</li>
<li><h5 id="Activity的工作过程"><a href="#Activity的工作过程" class="headerlink" title="Activity的工作过程"></a>Activity的工作过程</h5><h6 id="activity是如何启动？"><a href="#activity是如何启动？" class="headerlink" title="activity是如何启动？"></a>activity是如何启动？</h6><p><img src="/2018/03/31/Android开发艺术探索总结/activity启动流程.jpg" alt=""></p>
</li>
<li><h5 id="Service的工作过程"><a href="#Service的工作过程" class="headerlink" title="Service的工作过程"></a>Service的工作过程</h5><p><img src="/2018/03/31/Android开发艺术探索总结/service_lifecycle.jpg" alt=""></p>
<h6 id="Service的启动过程和绑定过程"><a href="#Service的启动过程和绑定过程" class="headerlink" title="Service的启动过程和绑定过程"></a>Service的启动过程和绑定过程</h6><h6 id="如何保证Service不被杀死？"><a href="#如何保证Service不被杀死？" class="headerlink" title="如何保证Service不被杀死？"></a>如何保证Service不被杀死？</h6><ul>
<li>1.onStartCommand方法，返回START_STICKY</li>
<li>2.提升service优先级</li>
<li>3.提升service进程优先级</li>
<li>4.onDestroy方法里重启service</li>
<li>5.Application加上Persistent属性</li>
<li>6.双进程保护,两个Service相互唤醒</li>
<li>7.使用JobService(5.0之后)</li>
</ul>
<h6 id="怎么在Service中创建Dialog对话框"><a href="#怎么在Service中创建Dialog对话框" class="headerlink" title="怎么在Service中创建Dialog对话框"></a>怎么在Service中创建Dialog对话框</h6><ol>
<li><p><strong>在Service中创建</strong></p>
<ul>
<li><p>1.构建Dialog对象之后，在show()方法之前设置Dialog 的Window类型为系统警告弹框<br><code>mDialog.getWindow.setType(WindowManger.LayoutParams.TYPE_SYSYTEM_ALERT)</code></p>
</li>
<li><p>2.在AndroidManifest清单文件的申明对应的权限<code>android.permission.SYSTEM_ALERT_WINDOW</code></p>
</li>
<li><p>3.对于6.0以上的版本还需要申请运行时权限：在activity的onResume中判断是否允许绘制叠加层– <code>Settings.canDrawOverlays()</code>，没有则请求。</p>
</li>
</ul>
<p><img src="/2018/03/31/Android开发艺术探索总结/dialog.png" alt=""></p>
</li>
<li><p><strong>在Service中发送广播在Activity中显示</strong></p>
</li>
</ol>
</li>
</ol>
<h4 id="Android的消息机制"><a href="#Android的消息机制" class="headerlink" title="Android的消息机制"></a>Android的消息机制</h4><ol>
<li><h5 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h5> android的消息机制是指Handler的运行机制以及Handler所附带的MessageQueue和Looperd的工作过程，三者是一个整体。Handler 的主要任务是将任务切换到某个指定的线程去执行。</li>
<li><h5 id="消息机制原理"><a href="#消息机制原理" class="headerlink" title="消息机制原理"></a>消息机制原理</h5> <code>message:</code>包含事件的信息以及消息的处理对象,message.next()指向下一个可用的message<br> <code>MessageQueue:</code>一组以单链表形式维护的待处理的消息；<br> <code>Looper:</code>消息循环<br> <code>Handler:</code>消息投递、处理器。<br> <img src="/2018/03/31/Android开发艺术探索总结/Handler消息机制.jpg" alt=""><br> <strong>讲人话====&gt;整个机制就像工厂的生成线，Message是待处理的产品，MessageQueu是传送带，Looper是发动机，而Handler则是工人。工人在生产线一端Thread 1投送待处理的产品Message到传送带MessageQueue上，经过发送机Looper的不停循环转动传送到生产线另一端Thread 2,然后工人拿出产品做相应的处理。</strong></li>
<li><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5> ThreadLocal是线程内部的数据存储类，通过它可以在制定的线程中存储数据，数据存储之后只能在指定的线程中获取到存储的数据，对于其他线程来说则无法获取到。<br> <code>使用时机</code>：当某些数据是以线程为作用域，并且不同线程具有不同的数据副本时。比如,线程的Looper,作用域为当前线程且不线程有不同的Looper;全局的监听器对象。</li>
<li><h5 id="在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"><a href="#在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？" class="headerlink" title="在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"></a>在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？</h5> 因为每个Handler会关联一个消息列队，而消息列队被封装在Looper中，但是每个Looper又是存储在ThreadLocal中的，基于ThreadLocal的特性，也就是说每个消息列队只属于一个线程。因此，如果Looper在线程A中创建，那么Looper只能被线程A访问。不带参数的Handler默认获取了UI线程中的MianLooper,作为消息投递，处理的Handler，要想访问MainLooper所在线程中的消息列队，必须在与之相同的线程中，即UI线程中创建。</li>
<li><h5 id="只能在主线程中更新UI，这种说法对吗？"><a href="#只能在主线程中更新UI，这种说法对吗？" class="headerlink" title="只能在主线程中更新UI，这种说法对吗？"></a>只能在主线程中更新UI，这种说法对吗？</h5></li>
<li><h5 id="Handler导致的内存泄漏"><a href="#Handler导致的内存泄漏" class="headerlink" title="Handler导致的内存泄漏"></a>Handler导致的内存泄漏</h5><p> 造成泄漏的诱因有两个：1、主线程中的Looper对象的生命周期==应用的生命周期；2、在java中菲静态内部类和匿名内部类默认持有外部类的引用。<br> 由于Looper内部消息队列中的Message默认包含了对处理者handler的引用(msg.traget=handler)，而handler实例默认持有外部类，也就是activity的引用，如果在activity结束时，还有未处理的消息或者正在处理消息，使得引用关系继续保持，从而导致外部类无法被销毁回收，造成内存泄漏。<br> <strong>解决方法：</strong></p>
<ul>
<li><p>1.外部类结束生命周期时清空handler内的消息列队，比如在onDestory中调用 mHandler.removeCallbacksAndMessages(null);</p>
</li>
<li><p>2.将handler设置成静态内部类并对外部类进行弱引用。</p>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li><h5 id="为什么一个线程只有一个Looper、只有一个MessageQueue？"><a href="#为什么一个线程只有一个Looper、只有一个MessageQueue？" class="headerlink" title="为什么一个线程只有一个Looper、只有一个MessageQueue？"></a>为什么一个线程只有一个Looper、只有一个MessageQueue？</h5></li>
<li><h5 id="如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）"><a href="#如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）" class="headerlink" title="如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）"></a>如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）</h5></li>
<li><h5 id="是不是任何线程都可以实例化Handler？有没有什么约束条件？"><a href="#是不是任何线程都可以实例化Handler？有没有什么约束条件？" class="headerlink" title="是不是任何线程都可以实例化Handler？有没有什么约束条件？"></a>是不是任何线程都可以实例化Handler？有没有什么约束条件？</h5></li>
<li><h5 id="Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"><a href="#Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？" class="headerlink" title="Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"></a>Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</h5></li>
<li><h6 id="Handler-sendMessageDelayed-怎么实现延迟的？结合Looper-loop-循环中，Message-messageQueue-next-和MessageQueue-enqueueMessage-分析。"><a href="#Handler-sendMessageDelayed-怎么实现延迟的？结合Looper-loop-循环中，Message-messageQueue-next-和MessageQueue-enqueueMessage-分析。" class="headerlink" title="Handler.sendMessageDelayed()怎么实现延迟的？结合Looper.loop()循环中，Message=messageQueue.next()和MessageQueue.enqueueMessage()分析。"></a>Handler.sendMessageDelayed()怎么实现延迟的？结合Looper.loop()循环中，Message=messageQueue.next()和MessageQueue.enqueueMessage()分析。</h6></li>
</ol>
<h4 id="Android的线程和线程池"><a href="#Android的线程和线程池" class="headerlink" title="Android的线程和线程池"></a>Android的线程和线程池</h4><ol>
<li><h5 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h5>进程所拥有的的线程叫做主线程，除主线程之外的线程叫做子线程，或工作线程。<br>主线程主要用来是运行四大组件以及处理界面交互相关的逻辑，子线程用来执行耗时操作。</li>
<li><h5 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h5><ol>
<li>传统的Thread</li>
<li>AsyncTask</li>
<li>HandlerThread</li>
<li>IntentService</li>
</ol>
</li>
<li><h5 id="HandlerThread、IntentService理解"><a href="#HandlerThread、IntentService理解" class="headerlink" title="HandlerThread、IntentService理解"></a>HandlerThread、IntentService理解</h5><p>？？？？？？？？</p>
</li>
<li><h5 id="android中的线程池"><a href="#android中的线程池" class="headerlink" title="android中的线程池"></a>android中的线程池</h5><strong>线程池的优点</strong><ul>
<li>重用线程池中线程，避免线程创建和销毁带来的性能开销</li>
<li>能有效控制线程的最大并发数，避免大量线程之间因相互枪战系统资源而导致阻塞。</li>
<li>能够对线程进行简单的控制</li>
</ul>
</li>
<li><strong>线程池的分类</strong><ul>
<li>FixedThreadPool :固定线程数，空闲状态不会被回收</li>
<li>CachedThreadPool : 线程数量不固定，只有非核心线程，闲置状态是被停止</li>
<li>ScheduledThreadPool  :核心线程固定，非核心线程不固定，闲置回收，执行定时或者周期任务</li>
<li>SingleThreadPool :只有一个核心线程，任务在同一个线程中顺序执行</li>
</ul>
</li>
<li><strong>线程池的参数详解</strong><br>？？？？</li>
</ol>
<h4 id="Bitmap的加载和缓存"><a href="#Bitmap的加载和缓存" class="headerlink" title="Bitmap的加载和缓存"></a>Bitmap的加载和缓存</h4><ol>
<li><h5 id="Bitmap的高效加载"><a href="#Bitmap的高效加载" class="headerlink" title="Bitmap的高效加载"></a>Bitmap的高效加载</h5><p>核心思想是：采用BitmapFactory.Option设置采样率inSampleSzie来加载所需尺寸的图片。<br>获取采样率的流程：</p>
<ol>
<li>将BitmapFactory.Option的inJustDecodeBounds参数为true并加载图片;</li>
<li>从BitmapFactory.Option中解析出图片的原始宽高，它们对应于outWidth和outHeight;</li>
<li>根据采样率的规则、结合目标view的大小计算出采样率inSampleSize;</li>
<li>将BitmapFactoory.Option的inJustDecodeBounds设置为false,重新加载图片。</li>
</ol>
</li>
<li><h5 id="android的缓存策略"><a href="#android的缓存策略" class="headerlink" title="android的缓存策略"></a>android的缓存策略</h5><h5 id="android图片的三级缓存"><a href="#android图片的三级缓存" class="headerlink" title="android图片的三级缓存"></a>android图片的三级缓存</h5><ol>
<li><p>首次加载的时候通过网络加载，获取图片，然后保存到内存和 SD 卡中；</p>
</li>
<li><p>之后运行 APP 时，优先访问内存中的图片缓存；</p>
</li>
<li><p>如果内存中没有，则加载本地 SD 卡中的图片,如果内存中没有最后再从网络获取。</p>
<p><strong>具体的缓存策略可以是这样的：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用 LruCache ，其内部通过 LinkedhashMap 以强引用的方式存储外界的缓存对象；对于本地缓存，使用 DiskLruCache。加载图片的时候，首先使用 LRU 方式进行寻找，若找不到指定内容，按照三级缓存的方式，进行本地搜索，还没有就网络加载。</strong></p>
</li>
</ol>
</li>
</ol>
<h4 id="Android的性能优化"><a href="#Android的性能优化" class="headerlink" title="Android的性能优化"></a>Android的性能优化</h4><h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><ol>
<li><h5 id="简述TCP建立连接的三次握手及原因？"><a href="#简述TCP建立连接的三次握手及原因？" class="headerlink" title="简述TCP建立连接的三次握手及原因？"></a>简述TCP建立连接的三次握手及原因？</h5><blockquote>
<p>TCP的传输可靠的、无差错的</p>
</blockquote>
<p> <img src="/2018/03/31/Android开发艺术探索总结/TCP_shake_hands_LI.jpg" alt=""><br> <strong>原因：</strong></p>
<blockquote>
<p>防止服务器接收到早已失效的连接请求，从而一直等待客户端的请求，导致形成锁死、浪费资源</p>
</blockquote>
<p>假设不采用“三次握手”，即服务器发出确认报文后，TCP连接就建立起来，但是客户端并没有继续发出建立连接的请求报文，因此不会给服务器发送数据，对于客户端来说，该报文已经失效，但是服务器以为TCP连接已建立，然后一直等待客户端发送数据，会形成锁死。<br><strong>就好比</strong>：</p>
<blockquote>
<p>老板只是查个岗，于是在群里随便问：小明在吗？</p>
</blockquote>
<blockquote>
<p>然后就看到了小明迅速的恢复：在的,老板！</p>
</blockquote>
<blockquote>
<p>老板心想：果然没看错小明！然后老板忙自己的去了。</p>
</blockquote>
<p>这时候要是小明是个二货（不进行三次握手），以为老本板有什么任务交给他，就傻傻的等着，等了一天老板也没再说话。这就是不进行三次握手的结果—锁死、浪费资源。</p>
</li>
</ol>
<ol start="2">
<li><h5 id="TCP四次分手"><a href="#TCP四次分手" class="headerlink" title="TCP四次分手"></a>TCP四次分手</h5><p><img src="/2018/03/31/Android开发艺术探索总结/TCP_wave_hands.png" alt=""></p>
<blockquote>
<p><strong>解析：</strong></p>
</blockquote>
<p>假设老板和小明都在加班，一起加班，共同加班——&gt;<code>数据双向传输</code><br>老板一看表两点了啊，于是<br><code>数据单向传输</code><br>老板：小明你的模块提交了没有，提交了早点回去休息，明天还上班呢！</p>
<pre><code>客户端|终止等待1
</code></pre><p>小明：还有一点，马上就好!</p>
<pre><code>服务器|关闭等待
客户端|终止等待2
</code></pre><p>转眼三点了，小明也完成了工具，于是：<br>小明：老板，醒醒，醒醒，我的模块提交了！</p>
<pre><code>服务器|最终确认
</code></pre><p>老板：额，什么，好，我在看一下，你可以走了！明天不要迟到！<br>然后，小明拖着疲倦的身体回了；</p>
<pre><code>服务器|关闭
</code></pre><p>过了没多久—-等小明真的走了</p>
<pre><code>客户端|时间等待
</code></pre><p>老板也收拾东西，开车回家了。</p>
<pre><code>客户端|关闭
</code></pre></li>
<li><h5 id="为什么客户端关闭连接前要等待2MSL时间？"><a href="#为什么客户端关闭连接前要等待2MSL时间？" class="headerlink" title="为什么客户端关闭连接前要等待2MSL时间？"></a>为什么客户端关闭连接前要等待2MSL时间？</h5><p> <code>MSL</code>–最长报文寿命（Maximum Segment Lifetime），报文在网络中存活的事件。</p>
<ul>
<li><p>原因1：为了保证客户端发送的最后1个连接释放确认报文能到达服务器，从而使得服务器能正常释放连接；</p>
</li>
<li><p>原因2：防止客户端已失效的连接请求报文出现在连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。</p>
</li>
</ul>
</li>
<li><h5 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h5></li>
</ol>
<h4 id="Http-Https"><a href="#Http-Https" class="headerlink" title="Http/Https"></a>Http/Https</h4><h4 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h4><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><h4 id="弱引用、软引用区别"><a href="#弱引用、软引用区别" class="headerlink" title="弱引用、软引用区别"></a>弱引用、软引用区别</h4><h4 id="int、Integer有什么区别"><a href="#int、Integer有什么区别" class="headerlink" title="int、Integer有什么区别"></a>int、Integer有什么区别</h4><h4 id="动态权限适配问题、换肤实现原理"><a href="#动态权限适配问题、换肤实现原理" class="headerlink" title="动态权限适配问题、换肤实现原理"></a>动态权限适配问题、换肤实现原理</h4><p>  这方面看下鸿洋大神的博文吧</p>
<h4 id="SharedPreference原理，能否跨进程？如何实现？"><a href="#SharedPreference原理，能否跨进程？如何实现？" class="headerlink" title="SharedPreference原理，能否跨进程？如何实现？"></a>SharedPreference原理，能否跨进程？如何实现？</h4><h4 id="响应速度优化"><a href="#响应速度优化" class="headerlink" title="响应速度优化"></a>响应速度优化</h4><p>   Activity如果5秒之内无法响应屏幕触碰事件和键盘输入事件，就会出现ANR；<br>而BroadcastReceiver如果10秒之内还未执行操作也会出现ANR，<br>Serve20秒会出现ANR 为了避免ANR，可以开启子线程执行耗时操作，但是子线程不能更新UI，因此需要Handler消息机制、AsyncTask、IntentService进行线程通信。<br>备：出现ANR时，adb pull data/anr/tarces.txt 结合log分析</p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol>
<li><h6 id="单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"><a href="#单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理" class="headerlink" title="单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"></a>单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理</h6></li>
<li><h6 id="观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"><a href="#观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式" class="headerlink" title="观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"></a>观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式</h6></li>
<li><h6 id="适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"><a href="#适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？" class="headerlink" title="适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"></a>适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？</h6></li>
<li><h6 id="建造者模式-工厂模式：要求会手写"><a href="#建造者模式-工厂模式：要求会手写" class="headerlink" title="建造者模式+工厂模式：要求会手写"></a>建造者模式+工厂模式：要求会手写</h6></li>
<li><h6 id="策略模式：这个问得比较少，不过有些做电商的会问。"><a href="#策略模式：这个问得比较少，不过有些做电商的会问。" class="headerlink" title="策略模式：这个问得比较少，不过有些做电商的会问。"></a>策略模式：这个问得比较少，不过有些做电商的会问。</h6></li>
<li><h6 id="MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"><a href="#MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行" class="headerlink" title="MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"></a>MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行</h6></li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li><h6 id="HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。"><a href="#HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。" class="headerlink" title="HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。"></a>HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。</h6></li>
<li><h6 id="ArrayList和LinkedList对比，这个相对简单一点。"><a href="#ArrayList和LinkedList对比，这个相对简单一点。" class="headerlink" title="ArrayList和LinkedList对比，这个相对简单一点。"></a>ArrayList和LinkedList对比，这个相对简单一点。</h6></li>
<li><h6 id="平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"><a href="#平衡二叉树、二叉查找树、红黑树，这几个我也被考到。" class="headerlink" title="平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"></a>平衡二叉树、二叉查找树、红黑树，这几个我也被考到。</h6></li>
<li><h6 id="Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"><a href="#Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。" class="headerlink" title="Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"></a>Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。</h6></li>
<li><h6 id="缓存淘汰策略-Lru"><a href="#缓存淘汰策略-Lru" class="headerlink" title="缓存淘汰策略(Lru)"></a>缓存淘汰策略(Lru)</h6></li>
</ol>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法主要考刷题吧，去LeetCode和牛客网刷下。</p>
<h4 id="热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的"><a href="#热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的" class="headerlink" title="热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)"></a>热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)</h4><p>了解classLoader</p>
<h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>项目中多多少少会用到开源框架，很多公司都喜欢问原理和是否看过源码，比如网络框架Okhttp，这是最常用的，现在Retrofit+RxJava也很流行。</p>
<ol>
<li><h5 id="网络框架库-Okhttp"><a href="#网络框架库-Okhttp" class="headerlink" title="网络框架库 Okhttp"></a>网络框架库 Okhttp</h5><p>okhttp源码一定要去看下，里面几个关键的类要记住，还有连接池，拦截器都需要理解。被问到如何给某些特定域名的url增加header，如果是自己封装的代码，可以在封装Request中可以解决，也可以增加拦截器，通过拦截器去做。<br>推荐一篇讲解<a href="https://www.jianshu.com/p/230e2e2988e0" target="_blank" rel="noopener">Okhttp</a>不错的文章</p>
</li>
<li><h5 id="消息通知-EventBus"><a href="#消息通知-EventBus" class="headerlink" title="消息通知 EventBus"></a>消息通知 EventBus</h5><h6 id="EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射"><a href="#EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射" class="headerlink" title="EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射"></a>EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射</h6><h6 id="EventBus可否跨进程问题？代替EventBus的方法（RxBus）"><a href="#EventBus可否跨进程问题？代替EventBus的方法（RxBus）" class="headerlink" title="EventBus可否跨进程问题？代替EventBus的方法（RxBus）"></a>EventBus可否跨进程问题？代替EventBus的方法（RxBus）</h6></li>
<li><h5 id="图片加载库（Fresco、Glide、Picasso）"><a href="#图片加载库（Fresco、Glide、Picasso）" class="headerlink" title="图片加载库（Fresco、Glide、Picasso）"></a>图片加载库（Fresco、Glide、Picasso）</h5><h6 id="项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"><a href="#项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别" class="headerlink" title="项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"></a>项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别</h6><h6 id="项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5-0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？"><a href="#项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5-0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？" class="headerlink" title="项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5.0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？"></a>项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5.0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？</h6></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/29/android总结/" rel="next" title="“android总结">
                <i class="fa fa-chevron-left"></i> “android总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/03/Java面试题集/" rel="prev" title="Java面试题集">
                Java面试题集 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yyg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/985211yygg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2289201033@qq.com" target="_blank" title="QQ-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>QQ-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-Fragment-的生命周期和启动模式"><span class="nav-number">1.</span> <span class="nav-text">Activity(Fragment)的生命周期和启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-生命周期分析"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 生命周期分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-Android的启动模式"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Android的启动模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-Acticity和Fragment的通信方式"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Acticity和Fragment的通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信IPC机制"><span class="nav-number">2.</span> <span class="nav-text">进程间通信IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是IPC？"><span class="nav-number">2.1.</span> <span class="nav-text">什么是IPC？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是多进程？"><span class="nav-number">2.2.</span> <span class="nav-text">什么是多进程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-Android-Binder跨进程通信的原理"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Android Binder跨进程通信的原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的事件体系"><span class="nav-number">3.</span> <span class="nav-text">View的事件体系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View的滑动"><span class="nav-number">3.1.</span> <span class="nav-text">View的滑动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件拦截和分发"><span class="nav-number">3.2.</span> <span class="nav-text">事件拦截和分发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#View的滑动冲突"><span class="nav-number">3.3.</span> <span class="nav-text">View的滑动冲突</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的工作原理"><span class="nav-number">4.</span> <span class="nav-text">View的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View的绘制流程："><span class="nav-number">4.1.</span> <span class="nav-text">View的绘制流程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#view的工作流程："><span class="nav-number">4.2.</span> <span class="nav-text">view的工作流程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义View"><span class="nav-number">4.3.</span> <span class="nav-text">自定义View</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android动画分析"><span class="nav-number">5.</span> <span class="nav-text">Android动画分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Android动画分类：view动画，属性动画和新增的物理动画"><span class="nav-number">5.1.</span> <span class="nav-text">Android动画分类：view动画，属性动画和新增的物理动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义view和view动画的特殊使用场景"><span class="nav-number">5.2.</span> <span class="nav-text">自定义view和view动画的特殊使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性动画："><span class="nav-number">5.3.</span> <span class="nav-text">属性动画：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性动画的工作原理："><span class="nav-number">5.4.</span> <span class="nav-text">属性动画的工作原理：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用动画的注意事项："><span class="nav-number">5.5.</span> <span class="nav-text">使用动画的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解Window和WinowManager"><span class="nav-number">6.</span> <span class="nav-text">理解Window和WinowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述："><span class="nav-number">6.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Window的内部机制"><span class="nav-number">6.2.</span> <span class="nav-text">Window的内部机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？"><span class="nav-number">6.3.</span> <span class="nav-text">PhoneWindow实例是在哪一个类哪一个方法中实例化的？也就是Winodow的创建过程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity的视图创建过程"><span class="nav-number">6.4.</span> <span class="nav-text">Activity的视图创建过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四大组件的工作过程"><span class="nav-number">7.</span> <span class="nav-text">四大组件的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Activity的工作过程"><span class="nav-number">7.2.</span> <span class="nav-text">Activity的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#activity是如何启动？"><span class="nav-number">7.2.1.</span> <span class="nav-text">activity是如何启动？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Service的工作过程"><span class="nav-number">7.3.</span> <span class="nav-text">Service的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Service的启动过程和绑定过程"><span class="nav-number">7.3.1.</span> <span class="nav-text">Service的启动过程和绑定过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如何保证Service不被杀死？"><span class="nav-number">7.3.2.</span> <span class="nav-text">如何保证Service不被杀死？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#怎么在Service中创建Dialog对话框"><span class="nav-number">7.3.3.</span> <span class="nav-text">怎么在Service中创建Dialog对话框</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的消息机制"><span class="nav-number">8.</span> <span class="nav-text">Android的消息机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述：-1"><span class="nav-number">8.1.</span> <span class="nav-text">概述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消息机制原理"><span class="nav-number">8.2.</span> <span class="nav-text">消息机制原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">8.3.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？"><span class="nav-number">8.4.</span> <span class="nav-text">在不传递Looperd参数给Handler构造函数的情况下，更新UI的Handler为什么必须在UI线程中创建？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#只能在主线程中更新UI，这种说法对吗？"><span class="nav-number">8.5.</span> <span class="nav-text">只能在主线程中更新UI，这种说法对吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handler导致的内存泄漏"><span class="nav-number">8.6.</span> <span class="nav-text">Handler导致的内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么一个线程只有一个Looper、只有一个MessageQueue？"><span class="nav-number">8.7.</span> <span class="nav-text">为什么一个线程只有一个Looper、只有一个MessageQueue？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）"><span class="nav-number">8.8.</span> <span class="nav-text">如何获取当前线程的Looper？是怎么实现的？（理解ThreadLocal）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#是不是任何线程都可以实例化Handler？有没有什么约束条件？"><span class="nav-number">8.9.</span> <span class="nav-text">是不是任何线程都可以实例化Handler？有没有什么约束条件？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Looper-loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？"><span class="nav-number">8.10.</span> <span class="nav-text">Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Handler-sendMessageDelayed-怎么实现延迟的？结合Looper-loop-循环中，Message-messageQueue-next-和MessageQueue-enqueueMessage-分析。"><span class="nav-number">8.10.1.</span> <span class="nav-text">Handler.sendMessageDelayed()怎么实现延迟的？结合Looper.loop()循环中，Message=messageQueue.next()和MessageQueue.enqueueMessage()分析。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的线程和线程池"><span class="nav-number">9.</span> <span class="nav-text">Android的线程和线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主线程和子线程"><span class="nav-number">9.1.</span> <span class="nav-text">主线程和子线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Android中的线程形态"><span class="nav-number">9.2.</span> <span class="nav-text">Android中的线程形态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HandlerThread、IntentService理解"><span class="nav-number">9.3.</span> <span class="nav-text">HandlerThread、IntentService理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android中的线程池"><span class="nav-number">9.4.</span> <span class="nav-text">android中的线程池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bitmap的加载和缓存"><span class="nav-number">10.</span> <span class="nav-text">Bitmap的加载和缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bitmap的高效加载"><span class="nav-number">10.1.</span> <span class="nav-text">Bitmap的高效加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android的缓存策略"><span class="nav-number">10.2.</span> <span class="nav-text">android的缓存策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#android图片的三级缓存"><span class="nav-number">10.3.</span> <span class="nav-text">android图片的三级缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的性能优化"><span class="nav-number">11.</span> <span class="nav-text">Android的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP和UDP"><span class="nav-number">12.</span> <span class="nav-text">TCP和UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简述TCP建立连接的三次握手及原因？"><span class="nav-number">12.1.</span> <span class="nav-text">简述TCP建立连接的三次握手及原因？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP四次分手"><span class="nav-number">12.2.</span> <span class="nav-text">TCP四次分手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么客户端关闭连接前要等待2MSL时间？"><span class="nav-number">12.3.</span> <span class="nav-text">为什么客户端关闭连接前要等待2MSL时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DDoS攻击"><span class="nav-number">12.4.</span> <span class="nav-text">DDoS攻击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Http-Https"><span class="nav-number">13.</span> <span class="nav-text">Http/Https</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java垃圾回收机制"><span class="nav-number">14.</span> <span class="nav-text">Java垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM"><span class="nav-number">15.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载机制"><span class="nav-number">16.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱引用、软引用区别"><span class="nav-number">17.</span> <span class="nav-text">弱引用、软引用区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int、Integer有什么区别"><span class="nav-number">18.</span> <span class="nav-text">int、Integer有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态权限适配问题、换肤实现原理"><span class="nav-number">19.</span> <span class="nav-text">动态权限适配问题、换肤实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SharedPreference原理，能否跨进程？如何实现？"><span class="nav-number">20.</span> <span class="nav-text">SharedPreference原理，能否跨进程？如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应速度优化"><span class="nav-number">21.</span> <span class="nav-text">响应速度优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设计模式"><span class="nav-number">22.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理"><span class="nav-number">22.0.1.</span> <span class="nav-text">单例模式：好几种写法，要求会手写，分析优劣。一般双重校验锁中用到volatile，需要分析volatile的原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式"><span class="nav-number">22.0.2.</span> <span class="nav-text">观察者模式：要求会手写，有些面试官会问你在项目中用到了吗？实在没有到的可以讲一讲EventBus，它用到的就是观察者模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？"><span class="nav-number">22.0.3.</span> <span class="nav-text">适配器模式：要求会手写，有些公司会问和装饰器模式、代理模式有什么区别？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#建造者模式-工厂模式：要求会手写"><span class="nav-number">22.0.4.</span> <span class="nav-text">建造者模式+工厂模式：要求会手写</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#策略模式：这个问得比较少，不过有些做电商的会问。"><span class="nav-number">22.0.5.</span> <span class="nav-text">策略模式：这个问得比较少，不过有些做电商的会问。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行"><span class="nav-number">22.0.6.</span> <span class="nav-text">MVC、MVP、MVVM：比较异同，选择一种你拿手的着重讲就行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">23.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。"><span class="nav-number">23.0.1.</span> <span class="nav-text">HashMap、LinkedHashMap、ConcurrentHashMap，在用法和原理上有什么差异，很多公司会考HashMap原理，通过它做一些扩展，比如中国13亿人口年龄的排序问题，年龄对应桶的个数，年龄相同和hash相同问题类似。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ArrayList和LinkedList对比，这个相对简单一点。"><span class="nav-number">23.0.2.</span> <span class="nav-text">ArrayList和LinkedList对比，这个相对简单一点。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#平衡二叉树、二叉查找树、红黑树，这几个我也被考到。"><span class="nav-number">23.0.3.</span> <span class="nav-text">平衡二叉树、二叉查找树、红黑树，这几个我也被考到。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。"><span class="nav-number">23.0.4.</span> <span class="nav-text">Set原理，这个和HashMap考得有点类似，考hash算法相关，被问到过常用hash算法。HashSet内部用到了HashMap。</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#缓存淘汰策略-Lru"><span class="nav-number">23.0.5.</span> <span class="nav-text">缓存淘汰策略(Lru)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法"><span class="nav-number">24.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热更新、热修复、插件化-这一块要求高点，一般高级工程师是需要理解的"><span class="nav-number">25.</span> <span class="nav-text">热更新、热修复、插件化(这一块要求高点，一般高级工程师是需要理解的)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码理解"><span class="nav-number">26.</span> <span class="nav-text">源码理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#网络框架库-Okhttp"><span class="nav-number">26.1.</span> <span class="nav-text">网络框架库 Okhttp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消息通知-EventBus"><span class="nav-number">26.2.</span> <span class="nav-text">消息通知 EventBus</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#EventBus原理：建议看下源码，不多。内部实现：观察者模式-注解-反射"><span class="nav-number">26.2.1.</span> <span class="nav-text">EventBus原理：建议看下源码，不多。内部实现：观察者模式+注解+反射</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EventBus可否跨进程问题？代替EventBus的方法（RxBus）"><span class="nav-number">26.2.2.</span> <span class="nav-text">EventBus可否跨进程问题？代替EventBus的方法（RxBus）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#图片加载库（Fresco、Glide、Picasso）"><span class="nav-number">26.3.</span> <span class="nav-text">图片加载库（Fresco、Glide、Picasso）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别"><span class="nav-number">26.3.1.</span> <span class="nav-text">项目中选择了哪个图片加载库？为什么选择它？其他库不好吗？这几个库的区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5-0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？"><span class="nav-number">26.3.2.</span> <span class="nav-text">项目中选择图片库它的原理，如Glide（LruCache结合弱引用），那么面试官会问LruCache原理，进而问LinkedHashMap原理，这样一层一层地问，所以建议看到不懂的追进去看。如Fresco是用来MVC设计模式，5.0以下是用了共享内存，那共享内存怎么用？Fresco怎么实现圆角？Fresco怎么配置缓存？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyg</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
