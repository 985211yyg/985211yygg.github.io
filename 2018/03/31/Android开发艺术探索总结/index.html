<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期        fragment的生命周期     与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发艺术探索总结">
<meta property="og:url" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/index.html">
<meta property="og:site_name" content="yyg的小黑屋">
<meta property="og:description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期        fragment的生命周期     与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle.png">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_launch_mode.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-c10d6032f91a103f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/Binder_module-table.PNG">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/IPC.PNG">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/android_view_hierarchy.jpg">
<meta property="og:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/motion_event_method.png">
<meta property="og:updated_time" content="2018-04-05T01:01:05.527Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发艺术探索总结">
<meta name="twitter:description" content="Activity(Fragment)的生命周期和启动模式1.1 生命周期分析 1.1.1 典型的生命周期   activity的生命周期        fragment的生命周期     与宿主Activity的生命周期的关系     onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？    对于这两对相似的接口，Android系统既然">
<meta name="twitter:image" content="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/"/>





  <title>Android开发艺术探索总结 | yyg的小黑屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yyg的小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yyglike.com/2018/03/31/Android开发艺术探索总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yyg">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yyg的小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android开发艺术探索总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-31T08:45:47+08:00">
                2018-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li><h4 id="Activity-Fragment-的生命周期和启动模式"><a href="#Activity-Fragment-的生命周期和启动模式" class="headerlink" title="Activity(Fragment)的生命周期和启动模式"></a>Activity(Fragment)的生命周期和启动模式</h4><h5 id="1-1-生命周期分析"><a href="#1-1-生命周期分析" class="headerlink" title="1.1 生命周期分析"></a>1.1 <strong>生命周期分析</strong></h5><ul>
<li><p>1.1.1 <strong>典型的生命周期</strong></p>
<ul>
<li><blockquote>
<p><strong>activity的生命周期</strong></p>
</blockquote>
</li>
</ul>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_lifecycle.PNG" alt=""></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_lifecycle_table.PNG" alt=""></p>
<ul>
<li><blockquote>
<p><strong>fragment的生命周期</strong></p>
</blockquote>
</li>
</ul>
<p><img src="/2018/03/31/Android开发艺术探索总结/fragment_lifecycle.png" alt=""></p>
<p><strong>与宿主Activity的生命周期的关系</strong></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle.png" alt=""></p>
<p><img src="/2018/03/31/Android开发艺术探索总结/activity_fragment_lifecycle_table.PNG" alt=""></p>
<ul>
<li><blockquote>
<p><strong>onStar和onResum、onPause和onStop从描述看起来差不多，对于我们来说有什么实质的不同呢？</strong></p>
</blockquote>
</li>
</ul>
<p>对于这两对相似的接口，Android系统既然提供了就有其用意：onSatrt和onStop是从activity这个角度来回调的，此时是无法操作的 ; onResume和onPause是从activity是否位于前台来回调，此时由可操作变为不克操作。</p>
</li>
<li><p>1.1.2 <strong>异常情况下的生命周期分析及一些思考问题</strong></p>
<ul>
<li><blockquote>
<p><strong>横竖屏切换时Activity的异常生命周期变化?</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">      Activity创建：</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      竖屏切横屏：</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">      onPause--&gt;</span><br><span class="line">      onStop--&gt;</span><br><span class="line">      onDestroy--&gt;</span><br><span class="line">      onCreate--&gt;</span><br><span class="line">      onStart--&gt;</span><br><span class="line">      onRestoreInstanceState--&gt;</span><br><span class="line">      onResume--&gt;</span><br><span class="line">      ============</span><br><span class="line">      横屏切换竖屏</span><br><span class="line">      onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br><span class="line">onSaveInstanceState--&gt;</span><br><span class="line">onPause--&gt;</span><br><span class="line">onStop--&gt;</span><br><span class="line">onDestroy--&gt;</span><br><span class="line">onCreate--&gt;</span><br><span class="line">onStart--&gt;</span><br><span class="line">onRestoreInstanceState--&gt;</span><br><span class="line">onResume--&gt;</span><br></pre></td></tr></table></figure>
<p>1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次</p>
<p>2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次</p>
<p>3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p>
<p>4、补充：Activity运行时按下HOME键(跟被完全覆盖是一样的)：onSaveInstanceState –&gt; onPause –&gt; onStop;重新回到Activity=： onRestart –&gt;onStart—&gt;onResume<br>  Activity未被完全覆盖只是失去焦点：onPause—&gt;onResume</p>
<ul>
<li><blockquote>
<p><strong> Activity是如何保存和恢复View的结构？</strong></p>
</blockquote>
</li>
</ul>
<p>首先，activity被意外终止时，activity会调用onSaveInstanceState()去保存数据，然后activity会委托Window去保存数据，接着window委托它的上级容器去保存数据。顶级容器是一个ViewGroup，一般可能是是DecorView。最后顶级容器再去一一通知子元素去保存数据，对于数据的恢复也是类似的。</p>
<ul>
<li><blockquote>
<p><strong>资源不足导致低优先级的activity被杀死 </strong></p>
</blockquote>
</li>
</ul>
<p>activity的优先级：<br>1.<code>前台activity</code>——正在和用户交互的activity，优先级最高<br>2.<code>可见但非前台activity</code>—–比如activity中弹出一个对话框，导致activity可见但是位于后台无法与直接交互。<br>3.<code>后台activity</code>—-已经被暂停的activity，比如执行了onStop(),优先级最低</p>
<p>对于系统内存不足时，系统会按照优先级来杀死目标activity的进程，然后通过onSaveInstanceState()和onRestoreInstanceState()存储恢复数据。</p>
<ul>
<li><blockquote>
<p><strong>假设当前activity为A,若此时用户打开activity B，那么 B 的onResume()和 A 的OnPause()那个先执行？</strong></p>
</blockquote>
</li>
</ul>
<p>当新启动一个activity时，位于栈顶的旧activity的onPause()会先执行，才会启动新的activity，另外Android对onPause()的解释是不能在其中进行重量级的操作，为了新的activity尽快出现在前台，所以资源回收等重量尽量在onStop()中进行，这也能说明onRsume()先执行。</p>
<ul>
<li><blockquote>
<p><strong> 通过 addToBackStack() 将 Fragment 放入回退栈，然后通过 popBackStack() 出栈，Fragment 的生命周期会如何变化呢？2. 如果 Fragment 与 ViewPager 结合使用，Fragment 的生命周期又是如何？3. 如果通过 hide() 和 show() 方法来展示隐藏，这时 Fragment 的生命周期又会如何？</strong></p>
</blockquote>
</li>
</ul>
<p>1.第一点很重要，最开始的两张图展示的 Fragment 与 Activity 的生命周期关系没毛病。</p>
<p>2.onAttach() 和 onCreate() 只在 Fragment 与 Activity 第一次关联时调用。</p>
<p>3.onDestroy() 和 onDetach() 只在 Fragment 的宿主 Activity 销毁时才会被调用。</p>
<p>4.根据前 3 点，将 Fragment 通过 addToBackStack() 只涉及 onCreateView() 和 onDestroyView() 这之间的生命周期。add() 和 replace() 不会对 Fragment 的生命周期产生影响，但 add() 方法会造成 Fragment 叠加显示。</p>
<p>5.Fragment 与 ViewPager 结合使用时的生命周期与第 4 点相似。</p>
<p>6.通过 hide() 、 show() 来隐藏、显示Fragment，此时 Fragment 只改变了可见性，并不涉及生命周期的改变</p>
<p>7.第 7 点与Fragment 和 Activity 的生命周期有关，即：不要在 Fragment 的 onCreate() 方法中操作宿主Activity 的 UI。因为你无法保证此时 宿主Activity 的 UI 已经完全初始化。PS:某些情况下是可以确保 宿主Activity 已经初始化完成的。</p>
<h5 id="1-2-Android的启动模式"><a href="#1-2-Android的启动模式" class="headerlink" title="1.2 Android的启动模式"></a>1.2 Android的启动模式</h5><p><img src="/2018/03/31/Android开发艺术探索总结/activity_launch_mode.PNG" alt=""></p>
<ul>
<li><blockquote>
<p><strong> activity的startActivity和context的startActivity区别</strong></p>
</blockquote>
<p>(1) 从Activity中启动新的Activity时可以直接mContext.startActivity(intent)就好，<br>(2) 如果从其他Context中启动Activity则必须给intent设置Flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK) ;</span><br><span class="line">mContext.startActivity(intent);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="1-3-Acticity和Fragment的通信方式"><a href="#1-3-Acticity和Fragment的通信方式" class="headerlink" title="1.3 Acticity和Fragment的通信方式"></a>1.3 Acticity和Fragment的通信方式</h5></li>
<li><h4 id="进程间通信IPC机制"><a href="#进程间通信IPC机制" class="headerlink" title="进程间通信IPC机制"></a>进程间通信IPC机制</h4><h5 id="2-1-什么是IPC？"><a href="#2-1-什么是IPC？" class="headerlink" title="2.1 什么是IPC？"></a>2.1 什么是IPC？</h5><p>IPC,Inter-Process Communication的缩写，含义为进程通信或者跨进程通信，是指两个进程之间进行数据交换的过程。<br><code>**线程**：</code>cup调度的最小单位<br><code>**进程**：</code>一般指一个执行单元，在PC和移动设备上指一个程序或者一个应用。<br><code>**ANR**:</code>在主线程中进行大量的耗时操作导致界面无法响应。</p>
<h5 id="2-2-什么是多进程？"><a href="#2-2-什么是多进程？" class="headerlink" title="2.2 什么是多进程？"></a>2.2 什么是多进程？</h5><ul>
<li><blockquote>
<p><strong>如何开启多进程？</strong></p>
</blockquote>
<p>Android中只有一种方式开启多进程，就是在四大组件的啊AndroidMenifest中指定android:process属性。</p>
</li>
<li><blockquote>
<p><strong>多进程的运行机制？</strong></p>
</blockquote>
<p>开启多进程造成的问题：</p>
<ul>
<li>静态成员和单列模式完成失效</li>
<li>线程同步机制失效</li>
<li>SharePreferences的可靠性失效</li>
<li>Application会多次创建</li>
</ul>
</li>
<li><blockquote>
<p><strong>进程隔离</strong></p>
</blockquote>
<p>为了保证 安全性 &amp; 独立性，一个进程 不能直接操作或者访问另一个进程，即Android的进程是<code>相互独立</code>、<code>隔离的</code></p>
</li>
</ul>
<h5 id="2-3-Android-Binder跨进程通信的原理"><a href="#2-3-Android-Binder跨进程通信的原理" class="headerlink" title="2.3 Android Binder跨进程通信的原理"></a>2.3 Android Binder跨进程通信的原理</h5><ul>
<li><blockquote>
<p><strong>Binder是什么？</strong><br>-<br><img src="https://upload-images.jianshu.io/upload_images/944365-45db4df339348b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br><strong>说人话—-</strong></p>
<ul>
<li><code>直观角度</code>：Binder是Android的一个类，实现了IBinder接口</li>
</ul>
</blockquote>
<ul>
<li><p><code>IPC角度</code>：Binder是Android一种跨进程通信的方式</p>
</li>
<li><p><code>Android Framework角度</code>: Binder是<code>ServiceManager</code>连接各        种Manager(<code>ActivityManager</code>、<code>WindowManger</code>)和相应ManagerService的桥梁</p>
</li>
<li><p><code>android应用层角度</code>：Binder是客户端和服务端进行通信的媒介。binderService的时候服务端会返回一个包含服务端业务调用的Binder对象，通过这个binder对象客户端可以获取服务端提供的服务和数据(包含该普通服务和基于AIDL的服务)</p>
</li>
</ul>
</li>
<li><blockquote>
<p><strong>Binder跨进程通信原理</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-c10d6032f91a103f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="通信原理图"></p>
<p><strong>各个模块的作用</strong>：<br><img src="/2018/03/31/Android开发艺术探索总结/Binder_module-table.PNG" alt="各模块的作用"></p>
</li>
<li><blockquote>
<p><strong>ServerManager是如何管理server的？</strong></p>
</blockquote>
<ul>
<li><p><strong>Binder Client 通过ServerManager获取Binder的引用，binder的引用是由SeverManager转换或者说映射得到的</strong>。</p>
</li>
<li><p><strong>Binder Server在生成一个Binder实体的同时会为其绑定一个名字，并将这个名字封装成一个数据包传递给Binder Driver</strong>；</p>
</li>
<li><p><strong>Binder Driver接收到数据包之后，如果是新的Binder，会为它在内存空间中创建相应的实体节点和一个对实体节点的引用，在源码中中分别对应Binder_node和Binder_ref；创建完后，Binder Driver 会将该引用传递给ServerManager;</strong></p>
</li>
<li><p><strong>ServerManager接收到之后会从中取出该Binder的名字和引用然后插入到一个数据表中，如此形成了类似DNS中存储的域名到真实IP的映射，然后Binder Client就可利用ServerManager通过名字查询Binder的引用，获取服务</strong>。</p>
</li>
<li><strong>当然Binder并非一定在ServerManager中有记录，很多时候Binder Server会将一个Binder实体封装进数据包传递给Binder Client,此时Binder server会在数据包中标注Binder实体的位置，Binder Driver会为该匿名的Binder生成实体节点和引用，并将引用通过映射传递给Binder Clien </strong></li>
</ul>
</li>
<li><blockquote>
<p><strong>跨进程通信的核心原理</strong></p>
</blockquote>
<p><strong>关于其核心原理：内存映射，具体请看文章：<a href="https://www.jianshu.com/p/719fc4758813" target="_blank" rel="noopener">操作系统：图文详解 内存映射</a> </strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-65a5b17426aed424.png?imageMogr2/auto-orient/" alt="Binder Driver"></p>
<p><strong>Binder通信原理图：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-d3c78b193c3e8a38.png?imageMogr2/auto-orient/" alt="Binder原理图"></p>
<blockquote>
<p><strong>Android的中IPC方式对比</strong></p>
</blockquote>
<p><img src="/2018/03/31/Android开发艺术探索总结/IPC.PNG" alt=""></p>
</li>
</ul>
</li>
<li><h4 id="View的事件体系"><a href="#View的事件体系" class="headerlink" title="View的事件体系"></a>View的事件体系</h4><h5 id="3-1-View的滑动"><a href="#3-1-View的滑动" class="headerlink" title="3.1 View的滑动"></a>3.1 View的滑动</h5><ul>
<li>使用scrollTo/scrollBy<br><code>scrollTo</code>:一次性滑动，屏幕左上角坐标为基准<br><code>scrollBy</code>:多次的，相对于当前位置的</li>
<li>使用动画</li>
<li>改变布局参数</li>
</ul>
<h5 id="3-2-事件拦截和分发"><a href="#3-2-事件拦截和分发" class="headerlink" title="3.2 事件拦截和分发"></a>3.2 事件拦截和分发</h5><p>   <img src="/2018/03/31/Android开发艺术探索总结/android_view_hierarchy.jpg" alt=""><br>   <strong>先来一段伪代码简单表示事件的传递规则</strong></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev)&#123;</span><br><span class="line">    boolean cousume = flase;</span><br><span class="line">    //拦截</span><br><span class="line">    if(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">        //消费</span><br><span class="line">       consume = onTouchEvent();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       //子view继续分发事件</span><br><span class="line">       consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    return consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MotionEvent=====&gt;Activty-----&gt;Window(PhoneWindow)-------&gt;DecorView----&gt;</span><br><span class="line">---&gt;顶级View(setContentView()，一般是ViewGroup)-------&gt;目标View</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说人话描述上面这段代码</strong>：</p>
</blockquote>
<p><strong>点击事件产生后，经过Activty,PhoneWindow,DecorView的分发传递，事件会传递给顶级View(一般是ViewGroup)，这时候它的dispatchTouchEvent()方法会被调用，如果内部的onInterceptTouchEvent()方法返回true,则表示它拦截当前的事件，特殊的如果ViewGroup的mOnTouchListener被设置，事件会被onTouch()处理，否则事件就正常交给ViewGroup的onTouchEvent()方法会处理；相反，如果ViewGroup的onInterceptTouchEvent()方法返回出false,则表示不拦截当前的事件，这时当前的事件就会传递它的子元素，接着子元素的dispatchTouchEvent()方法会被调用，如此反复直到事件被处理。</strong></p>
<p>   <img src="/2018/03/31/Android开发艺术探索总结/motion_event_method.png" alt=""></p>
<h5 id="3-3-View的滑动冲突"><a href="#3-3-View的滑动冲突" class="headerlink" title="3.3 View的滑动冲突"></a>3.3 View的滑动冲突</h5><ul>
<li><blockquote>
<p><strong>解决ScrollView嵌套ListView和GridView冲突的方法</strong></p>
</blockquote>
<p>重写ListView的onMeasure方法，来自定义高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"> int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST);</span><br><span class="line"> super.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要考察对MeasureSpec的三种模式的理解,相关文章.</p>
</li>
</ul>
</li>
<li><h4 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h4><ul>
<li><blockquote>
<p><strong>View的绘制流程：</strong></p>
</blockquote>
</li>
</ul>
<p>View的绘制是从ViewRoot的performTraversals()方法开始的，该方法会依次调用performMeasure、performLayout、performDraw三个方法，这三个方法依次完成顶级view的measure、layout、draw。其中perform会调用measure方法，在measure中有会调用onMeasure方法，在onMeasure方法中会对所有的子view进行measure，此时整个measure流程从父容器传到了子元素，完成一次measur过程，接着子元素会重复父容器的measure过程，如此反复完成整个view树的遍历。同理performLayout、performDraw与performMeasure的流程是类似的，最终完成view的绘制。</p>
<ul>
<li><blockquote>
<p><strong>view的工作流程：</strong></p>
</blockquote>
</li>
<li><p>主要是指measure、layout、draw这三大流程，其中measure确定view的测量宽/高；layout确定view的最终宽/高和四个顶点的位置；二draw将view绘制在屏幕上。</p>
<ul>
<li><p>对于view直接调用onMeasure方法来测量，而ViewGroup是抽象类，没有重写onMeasure方法，而是通过measureChildren遍历子元素，通过measureChild方法调用子元素的measure完成测量；</p>
</li>
<li><p>ViewGroup layout的大致流程：通过setFrame方法来设定view的四个顶点的位置，view的四个顶点一单确定view在父容器的中的位置也就确定，接着调用onLaytout确定子元素的位置;</p>
</li>
<li>Draw遵循步骤：<ul>
<li>1、绘制背景background.draw(canvas);</li>
<li>2、绘制自己onDraw;</li>
<li>3、绘制children–dispatchDraw;</li>
<li>4、绘制装饰—onDrawScrollBars.</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p><strong>自定义View</strong></p>
</blockquote>
<ul>
<li><p><strong>自定义View的分类及流程：</strong></p>
<ul>
<li><p>1、<strong>继承View重写onDraw方法</strong>；需要自己支持warp_content，处理padding；</p>
</li>
<li><p>2、<strong>继承ViewGroup派生特殊的布局</strong>，方法需要适当的处理ViewGroup的测量和布局的两个过程，并同时处理子元素的布局和测量过程。</p>
</li>
<li><p>3、<strong>继承特定的View</strong>，如TextView，对已有的功能进行拓展，无序自己支持warp_content，处理padding</p>
</li>
<li><p>4、<strong>继承特定的ViewGroup</strong>,如线性布局，此方法不需要自己处理ViewGroup的测量和布局。</p>
</li>
<li><strong>为了使自定义的View更易用，还需要添加自定义属性，以便在布局文件中使用：</strong><ul>
<li>1、在values目录中创建自定义属性xml文件，如attrs.在values目录中创建自定义属性xml文件</li>
<li>2、在view的构造方法中解析自定义的属性，并相应的处理，如定义默认值等。</li>
<li>3、在布局文件中声明然后使用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>直接继承view或者ViewGroup的控件，有时候warp_content达不到预期效果？</strong><br><code>原因</code>：当view在布局中使用warp_content，此时specMode为AT_MOST，宽高等于specSize，这种情况下View的specSize为parentSize,而parentSized的大小为父容器当前的剩余空间，使得和使用match_parent效果一致。</p>
<p><code>解决方法</code>：给View设定默认的宽/高，并在warp_content时根据情况设置此宽/高，即可。</p>
</li>
<li><p><strong>自定义View注意事项</strong></p>
<ul>
<li><p>1.让View支持warp_content</p>
</li>
<li><p>2.如有必要，让view支持padding</p>
</li>
<li><p>3.尽量不要在view中使用Handler,没必要，view本身提供post方法，完全可以替代Handler的作用，除非明确用handler来发送消息。</p>
</li>
<li><p>View中如果有线程或者动画，需要及时停止，View的OnDetachFromWindow是个好时机，当包含此view的Activity退出或者当前的View被remove是，此方法都会被调用。同事view背的不可见时候也需停止动画或者线程，避免内存泄漏。</p>
</li>
<li><p>View带有嵌套滑动的情形是，需要处理滑动冲突。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Android动画分析"><a href="#Android动画分析" class="headerlink" title="Android动画分析"></a>Android动画分析</h4><ul>
<li><p><strong>Android动画分类：view动画，属性动画和新增的物理动画</strong></p>
<ul>
<li><p><strong>View动画</strong>：对场景里的对象不断做图像变换（平移，缩放，旋转，透明度）从而产生一系列的动画效果，是一种渐进式动画，支持自定义；它包含该两个特殊的类型帧动画和补间动画：</p>
<ul>
<li>帧动画：通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片的切换动画。图片过多过大会导致oom;</li>
<li>补间动画：是帧动画的特殊形式，只需要提供开始图片和结束图片作为开始帧和结束帧，而动画的中间帧由系统计算补充。</li>
</ul>
</li>
<li><p><strong>属性动画</strong>：通过动态的改变对象的属性从而达到动画效果。</p>
</li>
<li><strong>物理动画</strong>：基于物理规律的动画效果。</li>
</ul>
</li>
<li><strong>自定义view和view动画的特殊使用场景</strong><ul>
<li><code>自定义view动画</code><br>继承Animation抽象类—-&gt;重写initialize和applyTransformation方法—–&gt;在initialize中做初始化工作，在applyTransformation中进行相应的矩阵变换。</li>
<li><code>view动画的特殊使用场景</code>：在ViewGroup中控制元素的出场效果，实现activity的出场动画。</li>
</ul>
</li>
<li><strong>属性动画：</strong><br>常见的几个动画类：ValueAnimator,ObjectAnimator,AnimatorSet。<br><code>插值器</code>：根据时间流逝的百分比来计算出当前属性值改变的百分比<br><code>估值器</code>:根据当前属性变化的百分比计算改变后的属性值<h5 id="属性动画的工作原理："><a href="#属性动画的工作原理：" class="headerlink" title="属性动画的工作原理："></a>属性动画的工作原理：</h5>在一定时间间隔内和值范围内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。因此要求作用的对象有该属性的set方法，如果没有设置初始值，还需要对象提供get方法，或者进行包装设置getter/setter方法。ValueAnimator不断控制值的变化，然后手动赋值给对象的属性，ObjectAnimator直接操作对象属性的值。<h5 id="使用动画的注意事项："><a href="#使用动画的注意事项：" class="headerlink" title="使用动画的注意事项："></a>使用动画的注意事项：</h5>1、帧动画中如果使用的图片过多多大容易出现OOM;<br>2、内存泄漏：属性动画中的无限循环动画需要在activity退出时及时停止，避免activity无法释放造成内存泄漏。<br>3、尽量使用dp保证在不同设备上的效果；<br>4、动画元素的交互问题：使用view动画移动之后点击事件还在原地，点击移动后的view无效======这是因为view动画只是对控件影像的操作，到达动画视觉的效果，而控件还留在原来的区域。</li>
</ul>
</li>
<li><h4 id="理解Window和WinowManager"><a href="#理解Window和WinowManager" class="headerlink" title="理解Window和WinowManager"></a>理解Window和WinowManager</h4><blockquote>
<p><strong>概述：</strong>Window表示一个窗口的概念，是一个抽象类，Android的所有视图都通过Window呈现，并依附于它，不管是activity、dialog、还是toast，是view的直接管理者。具体实现是PhoneWindow，通过WindowManager创建window，window的外界访问入口是WindowMananger，具体实现在WindowManagerServer中，因此windowmanger和WindowManagerServer的交互式IPC过程。</p>
</blockquote>
</li>
<li><h4 id="四大组件的工作过程"><a href="#四大组件的工作过程" class="headerlink" title="四大组件的工作过程"></a>四大组件的工作过程</h4><h5 id="7-1-Activity的工作过程"><a href="#7-1-Activity的工作过程" class="headerlink" title="7.1 Activity的工作过程"></a>7.1 Activity的工作过程</h5><ul>
<li><strong>activity是如何启动？</strong></li>
</ul>
<h5 id="7-2-Service的工作过程"><a href="#7-2-Service的工作过程" class="headerlink" title="7.2 Service的工作过程"></a>7.2 Service的工作过程</h5><ul>
<li><p><strong>Service的启动过程和绑定过程</strong></p>
</li>
<li><p><strong>如何保证Service不被杀死？</strong></p>
</li>
<li><p><strong>怎么在Service中创建Dialog对话框</strong></p>
</li>
</ul>
</li>
<li><h4 id="Android的消息机制"><a href="#Android的消息机制" class="headerlink" title="Android的消息机制"></a>Android的消息机制</h4></li>
<li><h4 id="Android的线程和线程池"><a href="#Android的线程和线程池" class="headerlink" title="Android的线程和线程池"></a>Android的线程和线程池</h4></li>
<li><h4 id="Bitmap的加载和缓存"><a href="#Bitmap的加载和缓存" class="headerlink" title="Bitmap的加载和缓存"></a>Bitmap的加载和缓存</h4></li>
<li><h4 id="Android的性能优化"><a href="#Android的性能优化" class="headerlink" title="Android的性能优化"></a>Android的性能优化</h4></li>
</ol>
<ol>
<li><h4 id="View相关"><a href="#View相关" class="headerlink" title="View相关"></a>View相关</h4><h5 id="1-1-View的绘制流程"><a href="#1-1-View的绘制流程" class="headerlink" title="1.1 View的绘制流程"></a>1.1 <em>View的绘制流程</em></h5><h5 id="1-2-自定义view的的步骤"><a href="#1-2-自定义view的的步骤" class="headerlink" title="1.2 自定义view的的步骤"></a>1.2 <em>自定义view的的步骤</em></h5><h5 id="1-3-PhoneWindow实例实在哪一个类方法中实例化的"><a href="#1-3-PhoneWindow实例实在哪一个类方法中实例化的" class="headerlink" title="1.3 PhoneWindow实例实在哪一个类方法中实例化的"></a>1.3 <em>PhoneWindow实例实在哪一个类方法中实例化的</em></h5><h5 id="1-4-Selector是如何实现的"><a href="#1-4-Selector是如何实现的" class="headerlink" title="1.4 Selector是如何实现的"></a>1.4 <em>Selector是如何实现的</em></h5><h5 id="1-5-View动画及如何实现的"><a href="#1-5-View动画及如何实现的" class="headerlink" title="1.5 View动画及如何实现的"></a>1.5 <em>View动画及如何实现的</em></h5><h5 id="1-6-为什么移动后的点击事件还在原来的位置"><a href="#1-6-为什么移动后的点击事件还在原来的位置" class="headerlink" title="1.6 为什么移动后的点击事件还在原来的位置"></a>1.6 <em>为什么移动后的点击事件还在原来的位置</em></h5><h5 id="1-7-属性动画的原理机制"><a href="#1-7-属性动画的原理机制" class="headerlink" title="1.7 属性动画的原理机制"></a>1.7 <em>属性动画的原理机制</em></h5></li>
<li><strong>Android系统源码部分</strong><br>2.1 <strong>Android事件的拦截和分发</strong><br>2.2 <strong>进程间的通信方式IPC</strong><br>2.3 <strong>应用的创建启动流程</strong></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/29/android总结/" rel="next" title="“android总结">
                <i class="fa fa-chevron-left"></i> “android总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/03/Java面试题集/" rel="prev" title="Java面试题集">
                Java面试题集 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yyg</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/985211yygg" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2289201033@qq.com" target="_blank" title="QQ-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>QQ-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-Fragment-的生命周期和启动模式"><span class="nav-number">1.</span> <span class="nav-text">Activity(Fragment)的生命周期和启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-生命周期分析"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 生命周期分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-Android的启动模式"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Android的启动模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-Acticity和Fragment的通信方式"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Acticity和Fragment的通信方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信IPC机制"><span class="nav-number">2.</span> <span class="nav-text">进程间通信IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-什么是IPC？"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 什么是IPC？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-什么是多进程？"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 什么是多进程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-Android-Binder跨进程通信的原理"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 Android Binder跨进程通信的原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的事件体系"><span class="nav-number">3.</span> <span class="nav-text">View的事件体系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-View的滑动"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 View的滑动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-事件拦截和分发"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 事件拦截和分发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-View的滑动冲突"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 View的滑动冲突</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View的工作原理"><span class="nav-number">4.</span> <span class="nav-text">View的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android动画分析"><span class="nav-number">5.</span> <span class="nav-text">Android动画分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#属性动画的工作原理："><span class="nav-number">5.1.</span> <span class="nav-text">属性动画的工作原理：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用动画的注意事项："><span class="nav-number">5.2.</span> <span class="nav-text">使用动画的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解Window和WinowManager"><span class="nav-number">6.</span> <span class="nav-text">理解Window和WinowManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四大组件的工作过程"><span class="nav-number">7.</span> <span class="nav-text">四大组件的工作过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-Activity的工作过程"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 Activity的工作过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-Service的工作过程"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 Service的工作过程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的消息机制"><span class="nav-number">8.</span> <span class="nav-text">Android的消息机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的线程和线程池"><span class="nav-number">9.</span> <span class="nav-text">Android的线程和线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bitmap的加载和缓存"><span class="nav-number">10.</span> <span class="nav-text">Bitmap的加载和缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android的性能优化"><span class="nav-number">11.</span> <span class="nav-text">Android的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View相关"><span class="nav-number">12.</span> <span class="nav-text">View相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-View的绘制流程"><span class="nav-number">12.1.</span> <span class="nav-text">1.1 View的绘制流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-自定义view的的步骤"><span class="nav-number">12.2.</span> <span class="nav-text">1.2 自定义view的的步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-PhoneWindow实例实在哪一个类方法中实例化的"><span class="nav-number">12.3.</span> <span class="nav-text">1.3 PhoneWindow实例实在哪一个类方法中实例化的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-Selector是如何实现的"><span class="nav-number">12.4.</span> <span class="nav-text">1.4 Selector是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-View动画及如何实现的"><span class="nav-number">12.5.</span> <span class="nav-text">1.5 View动画及如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-为什么移动后的点击事件还在原来的位置"><span class="nav-number">12.6.</span> <span class="nav-text">1.6 为什么移动后的点击事件还在原来的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-属性动画的原理机制"><span class="nav-number">12.7.</span> <span class="nav-text">1.7 属性动画的原理机制</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yyg</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
